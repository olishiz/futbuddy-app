"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_angular_fire_fesm2015_angular-fire-compat-firestore_js"],{

/***/ 60111:
/*!*************************************************************************!*\
  !*** ./node_modules/@angular/fire/fesm2015/angular-fire-compat-auth.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AngularFireAuth": () => (/* binding */ AngularFireAuth),
/* harmony export */   "AngularFireAuthModule": () => (/* binding */ AngularFireAuthModule),
/* harmony export */   "LANGUAGE_CODE": () => (/* binding */ LANGUAGE_CODE),
/* harmony export */   "PERSISTENCE": () => (/* binding */ PERSISTENCE),
/* harmony export */   "SETTINGS": () => (/* binding */ SETTINGS),
/* harmony export */   "TENANT_ID": () => (/* binding */ TENANT_ID),
/* harmony export */   "USE_DEVICE_LANGUAGE": () => (/* binding */ USE_DEVICE_LANGUAGE),
/* harmony export */   "USE_EMULATOR": () => (/* binding */ USE_EMULATOR),
/* harmony export */   "ɵauthFactory": () => (/* binding */ ɵauthFactory)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 14001);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 31883);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 38365);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ 4108);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs */ 41346);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs */ 65601);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 59271);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ 62257);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 8343);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ 84602);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ 3446);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs/operators */ 90062);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ 84006);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs/operators */ 88976);
/* harmony import */ var _angular_fire__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/fire */ 54385);
/* harmony import */ var _angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/fire/compat */ 33467);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/common */ 28267);
/* harmony import */ var _angular_fire_app_check__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @angular/fire/app-check */ 33578);
/* harmony import */ var firebase_compat_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/compat/app */ 84228);









 // DO NOT MODIFY, this file is autogenerated by tools/build.ts
// Export a null object with the same keys as firebase/compat/auth, so Proxy can work with proxy-polyfill in Internet Explorer

const proxyPolyfillCompat = {
  name: null,
  config: null,
  emulatorConfig: null,
  app: null,
  applyActionCode: null,
  checkActionCode: null,
  confirmPasswordReset: null,
  createUserWithEmailAndPassword: null,
  currentUser: null,
  fetchSignInMethodsForEmail: null,
  isSignInWithEmailLink: null,
  getRedirectResult: null,
  languageCode: null,
  settings: null,
  onAuthStateChanged: null,
  onIdTokenChanged: null,
  sendSignInLinkToEmail: null,
  sendPasswordResetEmail: null,
  setPersistence: null,
  signInAndRetrieveDataWithCredential: null,
  signInAnonymously: null,
  signInWithCredential: null,
  signInWithCustomToken: null,
  signInWithEmailAndPassword: null,
  signInWithPhoneNumber: null,
  signInWithEmailLink: null,
  signInWithPopup: null,
  signInWithRedirect: null,
  signOut: null,
  tenantId: null,
  updateCurrentUser: null,
  useDeviceLanguage: null,
  useEmulator: null,
  verifyPasswordResetCode: null
};
const USE_EMULATOR = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('angularfire2.auth.use-emulator');
const SETTINGS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('angularfire2.auth.settings');
const TENANT_ID = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('angularfire2.auth.tenant-id');
const LANGUAGE_CODE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('angularfire2.auth.langugage-code');
const USE_DEVICE_LANGUAGE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('angularfire2.auth.use-device-language');
const PERSISTENCE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('angularfire.auth.persistence');

const ɵauthFactory = (app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) => (0,_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__["ɵcacheInstance"])(`${app.name}.auth`, 'AngularFireAuth', app.name, () => {
  const auth = zone.runOutsideAngular(() => app.auth());

  if (useEmulator) {
    auth.useEmulator(...useEmulator);
  }

  if (tenantId) {
    auth.tenantId = tenantId;
  }

  auth.languageCode = languageCode;

  if (useDeviceLanguage) {
    auth.useDeviceLanguage();
  }

  if (settings) {
    for (const [k, v] of Object.entries(settings)) {
      auth.settings[k] = v;
    }
  }

  if (persistence) {
    auth.setPersistence(persistence);
  }

  return auth;
}, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);

class AngularFireAuth {
  constructor(options, name, // tslint:disable-next-line:ban-types
  platformId, zone, schedulers, useEmulator, // can't use the tuple here
  settings, // can't use firebase.auth.AuthSettings here
  tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {
    const logins = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
    const auth = (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)(undefined).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.observeOn)(schedulers.outsideAngular), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.switchMap)(() => zone.runOutsideAngular(() => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! firebase/compat/auth */ 81066)))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(() => (0,_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__["ɵfirebaseAppFactory"])(options, zone, name)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(app => ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.shareReplay)({
      bufferSize: 1,
      refCount: false
    }));

    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_9__.isPlatformServer)(platformId)) {
      this.authState = this.user = this.idToken = this.idTokenResult = this.credential = (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)(null);
    } else {
      // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth
      //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly
      //       as we're completely lazy. Let's eagerly load the Auth SDK here.
      //       There could potentially be race conditions still... but this greatly decreases the odds while
      //       we reevaluate the API.
      const _ = auth.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)()).subscribe();

      const redirectResult = auth.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.switchMap)(auth => auth.getRedirectResult().then(it => it, () => null)), _angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst, (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.shareReplay)({
        bufferSize: 1,
        refCount: false
      }));
      const authStateChanged = auth.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.switchMap)(auth => new rxjs__WEBPACK_IMPORTED_MODULE_12__.Observable(sub => ({
        unsubscribe: zone.runOutsideAngular(() => auth.onAuthStateChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))
      }))));
      const idTokenChanged = auth.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.switchMap)(auth => new rxjs__WEBPACK_IMPORTED_MODULE_12__.Observable(sub => ({
        unsubscribe: zone.runOutsideAngular(() => auth.onIdTokenChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))
      }))));
      this.authState = redirectResult.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.switchMapTo)(authStateChanged), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.subscribeOn)(schedulers.outsideAngular), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.observeOn)(schedulers.insideAngular));
      this.user = redirectResult.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.switchMapTo)(idTokenChanged), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.subscribeOn)(schedulers.outsideAngular), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.observeOn)(schedulers.insideAngular));
      this.idToken = this.user.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.switchMap)(user => user ? (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(user.getIdToken()) : (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)(null)));
      this.idTokenResult = this.user.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.switchMap)(user => user ? (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.from)(user.getIdTokenResult()) : (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)(null)));
      this.credential = (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.merge)(redirectResult, logins, // pipe in null authState to make credential zipable, just a weird devexp if
      // authState and user go null to still have a credential
      this.authState.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.filter)(it => !it))).pipe( // handle the { user: { } } when a user is already logged in, rather have null
      // TODO handle the type corcersion better
      (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(credential => (credential === null || credential === void 0 ? void 0 : credential.user) ? credential : null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.subscribeOn)(schedulers.outsideAngular), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.observeOn)(schedulers.insideAngular));
    }

    return (0,_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__["ɵlazySDKProxy"])(this, auth, zone, {
      spy: {
        apply: (name, _, val) => {
          // If they call a signIn or createUser function listen into the promise
          // this will give us the user credential, push onto the logins Subject
          // to be consumed in .credential
          if (name.startsWith('signIn') || name.startsWith('createUser')) {
            // TODO fix the types, the trouble is UserCredential has everything optional
            val.then(user => logins.next(user));
          }
        }
      }
    });
  }

}

AngularFireAuth.ɵfac = function AngularFireAuth_Factory(t) {
  return new (t || AngularFireAuth)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__.FIREBASE_OPTIONS), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__.FIREBASE_APP_NAME, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_fire__WEBPACK_IMPORTED_MODULE_11__["ɵAngularFireSchedulers"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](USE_EMULATOR, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](SETTINGS, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](TENANT_ID, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](LANGUAGE_CODE, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](USE_DEVICE_LANGUAGE, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](PERSISTENCE, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_fire_app_check__WEBPACK_IMPORTED_MODULE_18__.AppCheckInstances, 8));
};

AngularFireAuth.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: AngularFireAuth,
  factory: AngularFireAuth.ɵfac,
  providedIn: 'any'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](AngularFireAuth, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'any'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__.FIREBASE_OPTIONS]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__.FIREBASE_APP_NAME]
      }]
    }, {
      type: Object,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
      }]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone
    }, {
      type: _angular_fire__WEBPACK_IMPORTED_MODULE_11__["ɵAngularFireSchedulers"]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [USE_EMULATOR]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [SETTINGS]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [TENANT_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [LANGUAGE_CODE]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [USE_DEVICE_LANGUAGE]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [PERSISTENCE]
      }]
    }, {
      type: _angular_fire_app_check__WEBPACK_IMPORTED_MODULE_18__.AppCheckInstances,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional
      }]
    }];
  }, null);
})();

(0,_angular_fire_compat__WEBPACK_IMPORTED_MODULE_2__["ɵapplyMixins"])(AngularFireAuth, [proxyPolyfillCompat]);

class AngularFireAuthModule {
  constructor() {
    firebase_compat_app__WEBPACK_IMPORTED_MODULE_0__["default"].registerVersion('angularfire', _angular_fire__WEBPACK_IMPORTED_MODULE_11__.VERSION.full, 'auth-compat');
  }

}

AngularFireAuthModule.ɵfac = function AngularFireAuthModule_Factory(t) {
  return new (t || AngularFireAuthModule)();
};

AngularFireAuthModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
  type: AngularFireAuthModule
});
AngularFireAuthModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
  providers: [AngularFireAuth]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](AngularFireAuthModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      providers: [AngularFireAuth]
    }]
  }], function () {
    return [];
  }, null);
})();
/**
 * Generated bundle index. Do not edit.
 */




/***/ }),

/***/ 27091:
/*!******************************************************************************!*\
  !*** ./node_modules/@angular/fire/fesm2015/angular-fire-compat-firestore.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AngularFirestore": () => (/* binding */ AngularFirestore),
/* harmony export */   "AngularFirestoreCollection": () => (/* binding */ AngularFirestoreCollection),
/* harmony export */   "AngularFirestoreCollectionGroup": () => (/* binding */ AngularFirestoreCollectionGroup),
/* harmony export */   "AngularFirestoreDocument": () => (/* binding */ AngularFirestoreDocument),
/* harmony export */   "AngularFirestoreModule": () => (/* binding */ AngularFirestoreModule),
/* harmony export */   "ENABLE_PERSISTENCE": () => (/* binding */ ENABLE_PERSISTENCE),
/* harmony export */   "PERSISTENCE_SETTINGS": () => (/* binding */ PERSISTENCE_SETTINGS),
/* harmony export */   "SETTINGS": () => (/* binding */ SETTINGS),
/* harmony export */   "USE_EMULATOR": () => (/* binding */ USE_EMULATOR),
/* harmony export */   "associateQuery": () => (/* binding */ associateQuery),
/* harmony export */   "combineChange": () => (/* binding */ combineChange),
/* harmony export */   "combineChanges": () => (/* binding */ combineChanges),
/* harmony export */   "docChanges": () => (/* binding */ docChanges),
/* harmony export */   "fromCollectionRef": () => (/* binding */ fromCollectionRef),
/* harmony export */   "fromDocRef": () => (/* binding */ fromDocRef),
/* harmony export */   "fromRef": () => (/* binding */ fromRef),
/* harmony export */   "sortedChanges": () => (/* binding */ sortedChanges),
/* harmony export */   "validateEventsArray": () => (/* binding */ validateEventsArray)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/core */ 14001);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 72119);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 4108);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ 41346);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs */ 38365);
/* harmony import */ var _angular_fire__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/fire */ 54385);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 26660);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ 23808);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 8343);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ 60624);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ 17198);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ 88976);
/* harmony import */ var _angular_fire_compat__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/fire/compat */ 33467);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/common */ 28267);
/* harmony import */ var firebase_compat_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/compat/auth */ 81066);
/* harmony import */ var firebase_compat_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/compat/firestore */ 63846);
/* harmony import */ var _angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/fire/compat/auth */ 60111);
/* harmony import */ var _angular_fire_app_check__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @angular/fire/app-check */ 33578);
/* harmony import */ var firebase_compat_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/compat/app */ 84228);















function _fromRef(ref, scheduler = rxjs__WEBPACK_IMPORTED_MODULE_3__.asyncScheduler) {
  return new rxjs__WEBPACK_IMPORTED_MODULE_4__.Observable(subscriber => {
    let unsubscribe;

    if (scheduler != null) {
      scheduler.schedule(() => {
        unsubscribe = ref.onSnapshot({
          includeMetadataChanges: true
        }, subscriber);
      });
    } else {
      unsubscribe = ref.onSnapshot({
        includeMetadataChanges: true
      }, subscriber);
    }

    return () => {
      if (unsubscribe != null) {
        unsubscribe();
      }
    };
  });
}

function fromRef(ref, scheduler) {
  return _fromRef(ref, scheduler);
}

function fromDocRef(ref, scheduler) {
  return fromRef(ref, scheduler).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.startWith)(undefined), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.pairwise)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(([priorPayload, payload]) => {
    if (!payload.exists) {
      return {
        payload,
        type: 'removed'
      };
    }

    if (!(priorPayload === null || priorPayload === void 0 ? void 0 : priorPayload.exists)) {
      return {
        payload,
        type: 'added'
      };
    }

    return {
      payload,
      type: 'modified'
    };
  }));
}

function fromCollectionRef(ref, scheduler) {
  return fromRef(ref, scheduler).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(payload => ({
    payload,
    type: 'query'
  })));
}
/**
 * Return a stream of document changes on a query. These results are not in sort order but in
 * order of occurence.
 */


function docChanges(query, scheduler) {
  return fromCollectionRef(query, scheduler).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.startWith)(undefined), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.pairwise)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(([priorAction, action]) => {
    const docChanges = action.payload.docChanges();
    const actions = docChanges.map(change => ({
      type: change.type,
      payload: change
    })); // the metadata has changed from the prior emission

    if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {
      // go through all the docs in payload and figure out which ones changed
      action.payload.docs.forEach((currentDoc, currentIndex) => {
        const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));
        const priorDoc = priorAction === null || priorAction === void 0 ? void 0 : priorAction.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));

        if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) || !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {// document doesn't appear to have changed, don't log another action
        } else {
          // since the actions are processed in order just push onto the array
          actions.push({
            type: 'modified',
            payload: {
              oldIndex: currentIndex,
              newIndex: currentIndex,
              type: 'modified',
              doc: currentDoc
            }
          });
        }
      });
    }

    return actions;
  }));
}
/**
 * Return a stream of document changes on a query. These results are in sort order.
 */


function sortedChanges(query, events, scheduler) {
  return docChanges(query, scheduler).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.scan)((current, changes) => combineChanges(current, changes.map(it => it.payload), events), []), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.distinctUntilChanged)(), // cut down on unneed change cycles
  (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(changes => changes.map(c => ({
    type: c.type,
    payload: c
  }))));
}
/**
 * Combines the total result set from the current set of changes from an incoming set
 * of changes.
 */


function combineChanges(current, changes, events) {
  changes.forEach(change => {
    // skip unwanted change types
    if (events.indexOf(change.type) > -1) {
      current = combineChange(current, change);
    }
  });
  return current;
}
/**
 * Splice arguments on top of a sliced array, to break top-level ===
 * this is useful for change-detection
 */


function sliceAndSplice(original, start, deleteCount, ...args) {
  const returnArray = original.slice();
  returnArray.splice(start, deleteCount, ...args);
  return returnArray;
}
/**
 * Creates a new sorted array from a new change.
 * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning
 * and so we have greater control over change detection (by breaking ===)
 */


function combineChange(combined, change) {
  switch (change.type) {
    case 'added':
      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {// Not sure why the duplicates are getting fired
      } else {
        return sliceAndSplice(combined, change.newIndex, 0, change);
      }

      break;

    case 'modified':
      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {
        // When an item changes position we first remove it
        // and then add it's new position
        if (change.oldIndex !== change.newIndex) {
          const copiedArray = combined.slice();
          copiedArray.splice(change.oldIndex, 1);
          copiedArray.splice(change.newIndex, 0, change);
          return copiedArray;
        } else {
          return sliceAndSplice(combined, change.newIndex, 1, change);
        }
      }

      break;

    case 'removed':
      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {
        return sliceAndSplice(combined, change.oldIndex, 1);
      }

      break;
  }

  return combined;
}

function validateEventsArray(events) {
  if (!events || events.length === 0) {
    events = ['added', 'removed', 'modified'];
  }

  return events;
}
/**
 * AngularFirestoreCollection service
 *
 * This class creates a reference to a Firestore Collection. A reference and a query are provided in
 * in the constructor. The query can be the unqueried reference if no query is desired.The class
 * is generic which gives you type safety for data update methods and data streaming.
 *
 * This class uses Symbol.observable to transform into Observable using Observable.from().
 *
 * This class is rarely used directly and should be created from the AngularFirestore service.
 *
 * Example:
 *
 * const collectionRef = firebase.firestore.collection('stocks');
 * const query = collectionRef.where('price', '>', '0.01');
 * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);
 *
 * // NOTE!: the updates are performed on the reference not the query
 * await fakeStock.add({ name: 'FAKE', price: 0.01 });
 *
 * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.
 * fakeStock.valueChanges().subscribe(value => console.log(value));
 */


class AngularFirestoreCollection {
  /**
   * The constructor takes in a CollectionReference and Query to provide wrapper methods
   * for data operations and data streaming.
   *
   * Note: Data operation methods are done on the reference not the query. This means
   * when you update data it is not updating data to the window of your query unless
   * the data fits the criteria of the query. See the AssociatedRefence type for details
   * on this implication.
   */
  constructor(ref, query, afs) {
    this.ref = ref;
    this.query = query;
    this.afs = afs;
  }
  /**
   * Listen to the latest change in the stream. This method returns changes
   * as they occur and they are not sorted by query order. This allows you to construct
   * your own data structure.
   */


  stateChanges(events) {
    let source = docChanges(this.query, this.afs.schedulers.outsideAngular);

    if (events && events.length > 0) {
      source = source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(actions => actions.filter(change => events.indexOf(change.type) > -1)));
    }

    return source.pipe( // We want to filter out empty arrays, but always emit at first, so the developer knows
    // that the collection has been resolve; even if it's empty
    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.startWith)(undefined), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.pairwise)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.filter)(([prior, current]) => current.length > 0 || !prior), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(([prior, current]) => current), _angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }
  /**
   * Create a stream of changes as they occur it time. This method is similar to stateChanges()
   * but it collects each event in an array over time.
   */


  auditTrail(events) {
    return this.stateChanges(events).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.scan)((current, action) => [...current, ...action], []));
  }
  /**
   * Create a stream of synchronized changes. This method keeps the local array in sorted
   * query order.
   */


  snapshotChanges(events) {
    const validatedEvents = validateEventsArray(events);
    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);
    return scheduledSortedChanges$.pipe(_angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }

  valueChanges(options = {}) {
    return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(actions => actions.payload.docs.map(a => {
      if (options.idField) {
        return Object.assign(Object.assign({}, a.data()), {
          [options.idField]: a.id
        });
      } else {
        return a.data();
      }
    })), _angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }
  /**
   * Retrieve the results of the query once.
   */


  get(options) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.from)(this.query.get(options)).pipe(_angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }
  /**
   * Add data to a collection reference.
   *
   * Note: Data operation methods are done on the reference not the query. This means
   * when you update data it is not updating data to the window of your query unless
   * the data fits the criteria of the query.
   */


  add(data) {
    return this.ref.add(data);
  }
  /**
   * Create a reference to a single document in a collection.
   */


  doc(path) {
    // TODO is there a better way to solve this type issue
    return new AngularFirestoreDocument(this.ref.doc(path), this.afs);
  }

}
/**
 * AngularFirestoreDocument service
 *
 * This class creates a reference to a Firestore Document. A reference is provided in
 * in the constructor. The class is generic which gives you type safety for data update
 * methods and data streaming.
 *
 * This class uses Symbol.observable to transform into Observable using Observable.from().
 *
 * This class is rarely used directly and should be created from the AngularFirestore service.
 *
 * Example:
 *
 * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));
 * await fakeStock.set({ name: 'FAKE', price: 0.01 });
 * fakeStock.valueChanges().map(snap => {
 *   if(snap.exists) return snap.data();
 *   return null;
 * }).subscribe(value => console.log(value));
 * // OR! Transform using Observable.from() and the data is unwrapped for you
 * Observable.from(fakeStock).subscribe(value => console.log(value));
 */


class AngularFirestoreDocument {
  /**
   * The constructor takes in a DocumentReference to provide wrapper methods
   * for data operations, data streaming, and Symbol.observable.
   */
  constructor(ref, afs) {
    this.ref = ref;
    this.afs = afs;
  }
  /**
   * Create or overwrite a single document.
   */


  set(data, options) {
    return this.ref.set(data, options);
  }
  /**
   * Update some fields of a document without overwriting the entire document.
   */


  update(data) {
    return this.ref.update(data);
  }
  /**
   * Delete a document.
   */


  delete() {
    return this.ref.delete();
  }
  /**
   * Create a reference to a sub-collection given a path and an optional query
   * function.
   */


  collection(path, queryFn) {
    const collectionRef = this.ref.collection(path);
    const {
      ref,
      query
    } = associateQuery(collectionRef, queryFn);
    return new AngularFirestoreCollection(ref, query, this.afs);
  }
  /**
   * Listen to snapshot updates from the document.
   */


  snapshotChanges() {
    const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);
    return scheduledFromDocRef$.pipe(_angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }

  valueChanges(options = {}) {
    return this.snapshotChanges().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(({
      payload
    }) => options.idField ? Object.assign(Object.assign({}, payload.data()), {
      [options.idField]: payload.id
    }) : payload.data()));
  }
  /**
   * Retrieve the document once.
   */


  get(options) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.from)(this.ref.get(options)).pipe(_angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }

}
/**
 * AngularFirestoreCollectionGroup service
 *
 * This class holds a reference to a Firestore Collection Group Query.
 *
 * This class uses Symbol.observable to transform into Observable using Observable.from().
 *
 * This class is rarely used directly and should be created from the AngularFirestore service.
 *
 * Example:
 *
 * const collectionGroup = firebase.firestore.collectionGroup('stocks');
 * const query = collectionRef.where('price', '>', '0.01');
 * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);
 *
 * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.
 * fakeStock.valueChanges().subscribe(value => console.log(value));
 */


class AngularFirestoreCollectionGroup {
  /**
   * The constructor takes in a CollectionGroupQuery to provide wrapper methods
   * for data operations and data streaming.
   */
  constructor(query, afs) {
    this.query = query;
    this.afs = afs;
  }
  /**
   * Listen to the latest change in the stream. This method returns changes
   * as they occur and they are not sorted by query order. This allows you to construct
   * your own data structure.
   */


  stateChanges(events) {
    if (!events || events.length === 0) {
      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(_angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
    }

    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(actions => actions.filter(change => events.indexOf(change.type) > -1)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.filter)(changes => changes.length > 0), _angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }
  /**
   * Create a stream of changes as they occur it time. This method is similar to stateChanges()
   * but it collects each event in an array over time.
   */


  auditTrail(events) {
    return this.stateChanges(events).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.scan)((current, action) => [...current, ...action], []));
  }
  /**
   * Create a stream of synchronized changes. This method keeps the local array in sorted
   * query order.
   */


  snapshotChanges(events) {
    const validatedEvents = validateEventsArray(events);
    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);
    return scheduledSortedChanges$.pipe(_angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }

  valueChanges(options = {}) {
    const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);
    return fromCollectionRefScheduled$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.map)(actions => actions.payload.docs.map(a => {
      if (options.idField) {
        return Object.assign({
          [options.idField]: a.id
        }, a.data());
      } else {
        return a.data();
      }
    })), _angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }
  /**
   * Retrieve the results of the query once.
   */


  get(options) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.from)(this.query.get(options)).pipe(_angular_fire__WEBPACK_IMPORTED_MODULE_11__.keepUnstableUntilFirst);
  }

}
/**
 * The value of this token determines whether or not the firestore will have persistance enabled
 */


const ENABLE_PERSISTENCE = new _angular_core__WEBPACK_IMPORTED_MODULE_13__.InjectionToken('angularfire2.enableFirestorePersistence');
const PERSISTENCE_SETTINGS = new _angular_core__WEBPACK_IMPORTED_MODULE_13__.InjectionToken('angularfire2.firestore.persistenceSettings');
const SETTINGS = new _angular_core__WEBPACK_IMPORTED_MODULE_13__.InjectionToken('angularfire2.firestore.settings');
const USE_EMULATOR = new _angular_core__WEBPACK_IMPORTED_MODULE_13__.InjectionToken('angularfire2.firestore.use-emulator');
/**
 * A utility methods for associating a collection reference with
 * a query.
 *
 * @param collectionRef - A collection reference to query
 * @param queryFn - The callback to create a query
 *
 * Example:
 * const { query, ref } = associateQuery(docRef.collection('items'), ref => {
 *  return ref.where('age', '<', 200);
 * });
 */

function associateQuery(collectionRef, queryFn = ref => ref) {
  const query = queryFn(collectionRef);
  const ref = collectionRef;
  return {
    query,
    ref
  };
}
/**
 * AngularFirestore Service
 *
 * This service is the main entry point for this feature module. It provides
 * an API for creating Collection and Reference services. These services can
 * then be used to do data updates and observable streams of the data.
 *
 * Example:
 *
 * import { Component } from '@angular/core';
 * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';
 * import { Observable } from 'rxjs/Observable';
 * import { from } from 'rxjs/observable';
 *
 * @Component({
 *   selector: 'app-my-component',
 *   template: `
 *    <h2>Items for {{ (profile | async)?.name }}
 *    <ul>
 *       <li *ngFor="let item of items | async">{{ item.name }}</li>
 *    </ul>
 *    <div class="control-input">
 *       <input type="text" #itemname />
 *       <button (click)="addItem(itemname.value)">Add Item</button>
 *    </div>
 *   `
 * })
 * export class MyComponent implements OnInit {
 *
 *   // services for data operations and data streaming
 *   private readonly itemsRef: AngularFirestoreCollection<Item>;
 *   private readonly profileRef: AngularFirestoreDocument<Profile>;
 *
 *   // observables for template
 *   items: Observable<Item[]>;
 *   profile: Observable<Profile>;
 *
 *   // inject main service
 *   constructor(private readonly afs: AngularFirestore) {}
 *
 *   ngOnInit() {
 *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));
 *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));
 *     // this.items = from(this.itemsRef); // you can also do this with no mapping
 *
 *     this.profileRef = afs.doc('users/davideast');
 *     this.profile = this.profileRef.valueChanges();
 *   }
 *
 *   addItem(name: string) {
 *     const user = 'davideast';
 *     this.itemsRef.add({ name, user });
 *   }
 * }
 */


class AngularFirestore {
  /**
   * Each Feature of AngularFire has a FirebaseApp injected. This way we
   * don't rely on the main Firebase App instance and we can create named
   * apps and use multiple apps.
   */
  constructor(options, name, shouldEnablePersistence, settings, // tslint:disable-next-line:ban-types
  platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings, // can't use firebase.auth.AuthSettings here
  tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {
    this.schedulers = schedulers;
    const app = (0,_angular_fire_compat__WEBPACK_IMPORTED_MODULE_14__["ɵfirebaseAppFactory"])(options, zone, name);
    const useEmulator = _useEmulator;

    if (auth) {
      (0,_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__["ɵauthFactory"])(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);
    }

    [this.firestore, this.persistenceEnabled$] = (0,_angular_fire_compat__WEBPACK_IMPORTED_MODULE_14__["ɵcacheInstance"])(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {
      const firestore = zone.runOutsideAngular(() => app.firestore());

      if (settings) {
        firestore.settings(settings);
      }

      if (useEmulator) {
        firestore.useEmulator(...useEmulator);
      }

      if (shouldEnablePersistence && !(0,_angular_common__WEBPACK_IMPORTED_MODULE_16__.isPlatformServer)(platformId)) {
        // We need to try/catch here because not all enablePersistence() failures are caught
        // https://github.com/firebase/firebase-js-sdk/issues/608
        const enablePersistence = () => {
          try {
            return (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.from)(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));
          } catch (e) {
            if (typeof console !== 'undefined') {
              console.warn(e);
            }

            return (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.of)(false);
          }
        };

        return [firestore, zone.runOutsideAngular(enablePersistence)];
      } else {
        return [firestore, (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.of)(false)];
      }
    }, [settings, useEmulator, shouldEnablePersistence]);
  }

  collection(pathOrRef, queryFn) {
    let collectionRef;

    if (typeof pathOrRef === 'string') {
      collectionRef = this.firestore.collection(pathOrRef);
    } else {
      collectionRef = pathOrRef;
    }

    const {
      ref,
      query
    } = associateQuery(collectionRef, queryFn);
    const refInZone = this.schedulers.ngZone.run(() => ref);
    return new AngularFirestoreCollection(refInZone, query, this);
  }
  /**
   * Create a reference to a Firestore Collection Group based on a collectionId
   * and an optional query function to narrow the result
   * set.
   */


  collectionGroup(collectionId, queryGroupFn) {
    const queryFn = queryGroupFn || (ref => ref);

    const collectionGroup = this.firestore.collectionGroup(collectionId);
    return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);
  }

  doc(pathOrRef) {
    let ref;

    if (typeof pathOrRef === 'string') {
      ref = this.firestore.doc(pathOrRef);
    } else {
      ref = pathOrRef;
    }

    const refInZone = this.schedulers.ngZone.run(() => ref);
    return new AngularFirestoreDocument(refInZone, this);
  }
  /**
   * Returns a generated Firestore Document Id.
   */


  createId() {
    return this.firestore.collection('_').doc().id;
  }

}

AngularFirestore.ɵfac = function AngularFirestore_Factory(t) {
  return new (t || AngularFirestore)(_angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat__WEBPACK_IMPORTED_MODULE_14__.FIREBASE_OPTIONS), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat__WEBPACK_IMPORTED_MODULE_14__.FIREBASE_APP_NAME, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](ENABLE_PERSISTENCE, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](SETTINGS, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_13__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_13__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire__WEBPACK_IMPORTED_MODULE_11__["ɵAngularFireSchedulers"]), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](PERSISTENCE_SETTINGS, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](USE_EMULATOR, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.AngularFireAuth, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.USE_EMULATOR, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.SETTINGS, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.TENANT_ID, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.LANGUAGE_CODE, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.USE_DEVICE_LANGUAGE, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.PERSISTENCE, 8), _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵinject"](_angular_fire_app_check__WEBPACK_IMPORTED_MODULE_18__.AppCheckInstances, 8));
};

AngularFirestore.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵdefineInjectable"]({
  token: AngularFirestore,
  factory: AngularFirestore.ɵfac,
  providedIn: 'any'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵsetClassMetadata"](AngularFirestore, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Injectable,
    args: [{
      providedIn: 'any'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat__WEBPACK_IMPORTED_MODULE_14__.FIREBASE_OPTIONS]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat__WEBPACK_IMPORTED_MODULE_14__.FIREBASE_APP_NAME]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [ENABLE_PERSISTENCE]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [SETTINGS]
      }]
    }, {
      type: Object,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_13__.PLATFORM_ID]
      }]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.NgZone
    }, {
      type: _angular_fire__WEBPACK_IMPORTED_MODULE_11__["ɵAngularFireSchedulers"]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [PERSISTENCE_SETTINGS]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [USE_EMULATOR]
      }]
    }, {
      type: _angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.AngularFireAuth,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.USE_EMULATOR]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.SETTINGS]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.TENANT_ID]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.LANGUAGE_CODE]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.USE_DEVICE_LANGUAGE]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Inject,
        args: [_angular_fire_compat_auth__WEBPACK_IMPORTED_MODULE_15__.PERSISTENCE]
      }]
    }, {
      type: _angular_fire_app_check__WEBPACK_IMPORTED_MODULE_18__.AppCheckInstances,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.Optional
      }]
    }];
  }, null);
})();

class AngularFirestoreModule {
  constructor() {
    firebase_compat_app__WEBPACK_IMPORTED_MODULE_2__["default"].registerVersion('angularfire', _angular_fire__WEBPACK_IMPORTED_MODULE_11__.VERSION.full, 'fst-compat');
  }
  /**
   * Attempt to enable persistent storage, if possible
   */


  static enablePersistence(persistenceSettings) {
    return {
      ngModule: AngularFirestoreModule,
      providers: [{
        provide: ENABLE_PERSISTENCE,
        useValue: true
      }, {
        provide: PERSISTENCE_SETTINGS,
        useValue: persistenceSettings
      }]
    };
  }

}

AngularFirestoreModule.ɵfac = function AngularFirestoreModule_Factory(t) {
  return new (t || AngularFirestoreModule)();
};

AngularFirestoreModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵdefineNgModule"]({
  type: AngularFirestoreModule
});
AngularFirestoreModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵɵdefineInjector"]({
  providers: [AngularFirestore]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_13__["ɵsetClassMetadata"](AngularFirestoreModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_13__.NgModule,
    args: [{
      providers: [AngularFirestore]
    }]
  }], function () {
    return [];
  }, null);
})();
/**
 * Generated bundle index. Do not edit.
 */




/***/ }),

/***/ 47925:
/*!*********************************************************************************************!*\
  !*** ./node_modules/@angular/fire/node_modules/@firebase/auth-compat/dist/index.esm2017.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ 57251);
/* harmony import */ var _firebase_app_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/app-compat */ 80891);
/* harmony import */ var _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/auth/internal */ 46362);
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ 30504);
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ 47238);





var name = "@firebase/auth-compat";
var version = "0.4.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1000;

function _getCurrentScheme() {
  var _a;

  return ((_a = self === null || self === void 0 ? void 0 : self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
}
/**
 * @return {boolean} Whether the current environment is http or https.
 */


function _isHttpOrHttps() {
  return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
}
/**
 * @param {?string=} ua The user agent.
 * @return {boolean} Whether the app is rendered in a mobile iOS or Android
 *     Cordova environment.
 */


function _isAndroidOrIosCordovaScheme(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) {
  return !!((_getCurrentScheme() === 'file:' || _getCurrentScheme() === 'ionic:' || _getCurrentScheme() === 'capacitor:') && ua.toLowerCase().match(/iphone|ipad|ipod|android/));
}
/**
 * @return {boolean} Whether the environment is a native environment, where
 *     CORS checks do not apply.
 */


function _isNativeEnvironment() {
  return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isReactNative)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isNode)();
}
/**
 * Checks whether the user agent is IE11.
 * @return {boolean} True if it is IE11.
 */


function _isIe11() {
  return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIE)() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
}
/**
 * Checks whether the user agent is Edge.
 * @param {string} userAgent The browser user agent string.
 * @return {boolean} True if it is Edge.
 */


function _isEdge(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) {
  return /Edge\/\d+/.test(ua);
}
/**
 * @param {?string=} opt_userAgent The navigator user agent.
 * @return {boolean} Whether local storage is not synchronized between an iframe
 *     and a popup of the same domain.
 */


function _isLocalStorageNotSynchronized(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) {
  return _isIe11() || _isEdge(ua);
}
/** @return {boolean} Whether web storage is supported. */


function _isWebStorageSupported() {
  try {
    const storage = self.localStorage;

    const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._generateEventId();

    if (storage) {
      // setItem will throw an exception if we cannot access WebStorage (e.g.,
      // Safari in private mode).
      storage['setItem'](key, '1');
      storage['removeItem'](key); // For browsers where iframe web storage does not synchronize with a popup
      // of the same domain, indexedDB is used for persistent storage. These
      // browsers include IE11 and Edge.
      // Make sure it is supported (IE11 and Edge private mode does not support
      // that).

      if (_isLocalStorageNotSynchronized()) {
        // In such browsers, if indexedDB is not supported, an iframe cannot be
        // notified of the popup sign in result.
        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)();
      }

      return true;
    }
  } catch (e) {
    // localStorage is not available from a worker. Test availability of
    // indexedDB.
    return _isWorker() && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)();
  }

  return false;
}
/**
 * @param {?Object=} global The optional global scope.
 * @return {boolean} Whether current environment is a worker.
 */


function _isWorker() {
  // WorkerGlobalScope only defined in worker environment.
  return typeof global !== 'undefined' && 'WorkerGlobalScope' in global && 'importScripts' in global;
}

function _isPopupRedirectSupported() {
  return (_isHttpOrHttps() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isBrowserExtension)() || _isAndroidOrIosCordovaScheme()) && // React Native with remote debugging reports its location.protocol as
  // http.
  !_isNativeEnvironment() && // Local storage has to be supported for browser popup and redirect
  // operations to work.
  _isWebStorageSupported() && // DOM, popups and redirects are not supported within a worker.
  !_isWorker();
}
/** Quick check that indicates the platform *may* be Cordova */


function _isLikelyCordova() {
  return _isAndroidOrIosCordovaScheme() && typeof document !== 'undefined';
}

function _isCordova() {
  return _isCordova2.apply(this, arguments);
}

function _isCordova2() {
  _isCordova2 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
    if (!_isLikelyCordova()) {
      return false;
    }

    return new Promise(resolve => {
      const timeoutId = setTimeout(() => {
        // We've waited long enough; the telltale Cordova event didn't happen
        resolve(false);
      }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
      document.addEventListener('deviceready', () => {
        clearTimeout(timeoutId);
        resolve(true);
      });
    });
  });
  return _isCordova2.apply(this, arguments);
}

function _getSelfWindow() {
  return typeof window !== 'undefined' ? window : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const Persistence = {
  LOCAL: 'local',
  NONE: 'none',
  SESSION: 'session'
};
const _assert$3 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._assert;
const PERSISTENCE_KEY = 'persistence';
/**
 * Validates that an argument is a valid persistence value. If an invalid type
 * is specified, an error is thrown synchronously.
 */

function _validatePersistenceArgument(auth, persistence) {
  _assert$3(Object.values(Persistence).includes(persistence), auth, "invalid-persistence-type"
  /* exp.AuthErrorCode.INVALID_PERSISTENCE */
  ); // Validate if the specified type is supported in the current environment.


  if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isReactNative)()) {
    // This is only supported in a browser.
    _assert$3(persistence !== Persistence.SESSION, auth, "unsupported-persistence-type"
    /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */
    );

    return;
  }

  if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isNode)()) {
    // Only none is supported in Node.js.
    _assert$3(persistence === Persistence.NONE, auth, "unsupported-persistence-type"
    /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */
    );

    return;
  }

  if (_isWorker()) {
    // In a worker environment, either LOCAL or NONE are supported.
    // If indexedDB not supported and LOCAL provided, throw an error
    _assert$3(persistence === Persistence.NONE || persistence === Persistence.LOCAL && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)(), auth, "unsupported-persistence-type"
    /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */
    );

    return;
  } // This is restricted by what the browser supports.


  _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, "unsupported-persistence-type"
  /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */
  );
}

function _savePersistenceForRedirect(_x) {
  return _savePersistenceForRedirect2.apply(this, arguments);
}

function _savePersistenceForRedirect2() {
  _savePersistenceForRedirect2 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (auth) {
    yield auth._initializationPromise;
    const session = getSessionStorageIfAvailable();

    const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);

    if (session) {
      session.setItem(key, auth._getPersistence());
    }
  });
  return _savePersistenceForRedirect2.apply(this, arguments);
}

function _getPersistencesFromRedirect(apiKey, appName) {
  const session = getSessionStorageIfAvailable();

  if (!session) {
    return [];
  }

  const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);

  const persistence = session.getItem(key);

  switch (persistence) {
    case Persistence.NONE:
      return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.inMemoryPersistence];

    case Persistence.LOCAL:
      return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.indexedDBLocalPersistence, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserSessionPersistence];

    case Persistence.SESSION:
      return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserSessionPersistence];

    default:
      return [];
  }
}
/** Returns session storage, or null if the property access errors */


function getSessionStorageIfAvailable() {
  var _a;

  try {
    return ((_a = _getSelfWindow()) === null || _a === void 0 ? void 0 : _a.sessionStorage) || null;
  } catch (e) {
    return null;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const _assert$2 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._assert;
/** Platform-agnostic popup-redirect resolver */

class CompatPopupRedirectResolver {
  constructor() {
    // Create both resolvers for dynamic resolution later
    this.browserResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserPopupRedirectResolver);
    this.cordovaResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.cordovaPopupRedirectResolver); // The actual resolver in use: either browserResolver or cordovaResolver.

    this.underlyingResolver = null;
    this._redirectPersistence = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserSessionPersistence;
    this._completeRedirectFn = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._getRedirectResult;
    this._overrideRedirectResult = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._overrideRedirectResult;
  }

  _initialize(auth) {
    var _this = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this.selectUnderlyingResolver();
      return _this.assertedUnderlyingResolver._initialize(auth);
    })();
  }

  _openPopup(auth, provider, authType, eventId) {
    var _this2 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this2.selectUnderlyingResolver();
      return _this2.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId);
    })();
  }

  _openRedirect(auth, provider, authType, eventId) {
    var _this3 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this3.selectUnderlyingResolver();
      return _this3.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId);
    })();
  }

  _isIframeWebStorageSupported(auth, cb) {
    this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);
  }

  _originValidation(auth) {
    return this.assertedUnderlyingResolver._originValidation(auth);
  }

  get _shouldInitProactively() {
    return _isLikelyCordova() || this.browserResolver._shouldInitProactively;
  }

  get assertedUnderlyingResolver() {
    _assert$2(this.underlyingResolver, "internal-error"
    /* exp.AuthErrorCode.INTERNAL_ERROR */
    );

    return this.underlyingResolver;
  }

  selectUnderlyingResolver() {
    var _this4 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this4.underlyingResolver) {
        return;
      } // We haven't yet determined whether or not we're in Cordova; go ahead
      // and determine that state now.


      const isCordova = yield _isCordova();
      _this4.underlyingResolver = isCordova ? _this4.cordovaResolver : _this4.browserResolver;
    })();
  }

}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function unwrap(object) {
  return object.unwrap();
}

function wrapped(object) {
  return object.wrapped();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function credentialFromResponse(userCredential) {
  return credentialFromObject(userCredential);
}

function attachExtraErrorFields(auth, e) {
  var _a; // The response contains all fields from the server which may or may not
  // actually match the underlying type


  const response = (_a = e.customData) === null || _a === void 0 ? void 0 : _a._tokenResponse;

  if ((e === null || e === void 0 ? void 0 : e.code) === 'auth/multi-factor-auth-required') {
    const mfaErr = e;
    mfaErr.resolver = new MultiFactorResolver(auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.getMultiFactorResolver(auth, e));
  } else if (response) {
    const credential = credentialFromObject(e);
    const credErr = e;

    if (credential) {
      credErr.credential = credential;
      credErr.tenantId = response.tenantId || undefined;
      credErr.email = response.email || undefined;
      credErr.phoneNumber = response.phoneNumber || undefined;
    }
  }
}

function credentialFromObject(object) {
  const {
    _tokenResponse
  } = object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError ? object.customData : object;

  if (!_tokenResponse) {
    return null;
  } // Handle phone Auth credential responses, as they have a different format
  // from other backend responses (i.e. no providerId). This is also only the
  // case for user credentials (does not work for errors).


  if (!(object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError)) {
    if ('temporaryProof' in _tokenResponse && 'phoneNumber' in _tokenResponse) {
      return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.PhoneAuthProvider.credentialFromResult(object);
    }
  }

  const providerId = _tokenResponse.providerId; // Email and password is not supported as there is no situation where the
  // server would return the password to the client.

  if (!providerId || providerId === _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ProviderId.PASSWORD) {
    return null;
  }

  let provider;

  switch (providerId) {
    case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ProviderId.GOOGLE:
      provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.GoogleAuthProvider;
      break;

    case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ProviderId.FACEBOOK:
      provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.FacebookAuthProvider;
      break;

    case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ProviderId.GITHUB:
      provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.GithubAuthProvider;
      break;

    case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ProviderId.TWITTER:
      provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.TwitterAuthProvider;
      break;

    default:
      const {
        oauthIdToken,
        oauthAccessToken,
        oauthTokenSecret,
        pendingToken,
        nonce
      } = _tokenResponse;

      if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
        return null;
      } // TODO(avolkovi): uncomment this and get it working with SAML & OIDC


      if (pendingToken) {
        if (providerId.startsWith('saml.')) {
          return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.SAMLAuthCredential._create(providerId, pendingToken);
        } else {
          // OIDC and non-default providers excluding Twitter.
          return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.OAuthCredential._fromParams({
            providerId,
            signInMethod: providerId,
            pendingToken,
            idToken: oauthIdToken,
            accessToken: oauthAccessToken
          });
        }
      }

      return new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.OAuthProvider(providerId).credential({
        idToken: oauthIdToken,
        accessToken: oauthAccessToken,
        rawNonce: nonce
      });
  }

  return object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError ? provider.credentialFromError(object) : provider.credentialFromResult(object);
}

function convertCredential(auth, credentialPromise) {
  return credentialPromise.catch(e => {
    if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError) {
      attachExtraErrorFields(auth, e);
    }

    throw e;
  }).then(credential => {
    const operationType = credential.operationType;
    const user = credential.user;
    return {
      operationType,
      credential: credentialFromResponse(credential),
      additionalUserInfo: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.getAdditionalUserInfo(credential),
      user: User.getOrCreate(user)
    };
  });
}

function convertConfirmationResult(_x2, _x3) {
  return _convertConfirmationResult.apply(this, arguments);
}

function _convertConfirmationResult() {
  _convertConfirmationResult = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (auth, confirmationResultPromise) {
    const confirmationResultExp = yield confirmationResultPromise;
    return {
      verificationId: confirmationResultExp.verificationId,
      confirm: verificationCode => convertCredential(auth, confirmationResultExp.confirm(verificationCode))
    };
  });
  return _convertConfirmationResult.apply(this, arguments);
}

class MultiFactorResolver {
  constructor(auth, resolver) {
    this.resolver = resolver;
    this.auth = wrapped(auth);
  }

  get session() {
    return this.resolver.session;
  }

  get hints() {
    return this.resolver.hints;
  }

  resolveSignIn(assertion) {
    return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));
  }

}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class User {
  constructor(_delegate) {
    this._delegate = _delegate;
    this.multiFactor = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.multiFactor(_delegate);
  }

  static getOrCreate(user) {
    if (!User.USER_MAP.has(user)) {
      User.USER_MAP.set(user, new User(user));
    }

    return User.USER_MAP.get(user);
  }

  delete() {
    return this._delegate.delete();
  }

  reload() {
    return this._delegate.reload();
  }

  toJSON() {
    return this._delegate.toJSON();
  }

  getIdTokenResult(forceRefresh) {
    return this._delegate.getIdTokenResult(forceRefresh);
  }

  getIdToken(forceRefresh) {
    return this._delegate.getIdToken(forceRefresh);
  }

  linkAndRetrieveDataWithCredential(credential) {
    return this.linkWithCredential(credential);
  }

  linkWithCredential(credential) {
    var _this5 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return convertCredential(_this5.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.linkWithCredential(_this5._delegate, credential));
    })();
  }

  linkWithPhoneNumber(phoneNumber, applicationVerifier) {
    var _this6 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return convertConfirmationResult(_this6.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.linkWithPhoneNumber(_this6._delegate, phoneNumber, applicationVerifier));
    })();
  }

  linkWithPopup(provider) {
    var _this7 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return convertCredential(_this7.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.linkWithPopup(_this7._delegate, provider, CompatPopupRedirectResolver));
    })();
  }

  linkWithRedirect(provider) {
    var _this8 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._castAuth(_this8.auth));
      return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.linkWithRedirect(_this8._delegate, provider, CompatPopupRedirectResolver);
    })();
  }

  reauthenticateAndRetrieveDataWithCredential(credential) {
    return this.reauthenticateWithCredential(credential);
  }

  reauthenticateWithCredential(credential) {
    var _this9 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return convertCredential(_this9.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.reauthenticateWithCredential(_this9._delegate, credential));
    })();
  }

  reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }

  reauthenticateWithPopup(provider) {
    return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }

  reauthenticateWithRedirect(provider) {
    var _this10 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._castAuth(_this10.auth));
      return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.reauthenticateWithRedirect(_this10._delegate, provider, CompatPopupRedirectResolver);
    })();
  }

  sendEmailVerification(actionCodeSettings) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.sendEmailVerification(this._delegate, actionCodeSettings);
  }

  unlink(providerId) {
    var _this11 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.unlink(_this11._delegate, providerId);
      return _this11;
    })();
  }

  updateEmail(newEmail) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.updateEmail(this._delegate, newEmail);
  }

  updatePassword(newPassword) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.updatePassword(this._delegate, newPassword);
  }

  updatePhoneNumber(phoneCredential) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.updatePhoneNumber(this._delegate, phoneCredential);
  }

  updateProfile(profile) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.updateProfile(this._delegate, profile);
  }

  verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);
  }

  get emailVerified() {
    return this._delegate.emailVerified;
  }

  get isAnonymous() {
    return this._delegate.isAnonymous;
  }

  get metadata() {
    return this._delegate.metadata;
  }

  get phoneNumber() {
    return this._delegate.phoneNumber;
  }

  get providerData() {
    return this._delegate.providerData;
  }

  get refreshToken() {
    return this._delegate.refreshToken;
  }

  get tenantId() {
    return this._delegate.tenantId;
  }

  get displayName() {
    return this._delegate.displayName;
  }

  get email() {
    return this._delegate.email;
  }

  get photoURL() {
    return this._delegate.photoURL;
  }

  get providerId() {
    return this._delegate.providerId;
  }

  get uid() {
    return this._delegate.uid;
  }

  get auth() {
    return this._delegate.auth;
  }

} // Maintain a map so that there's always a 1:1 mapping between new User and
// legacy compat users


User.USER_MAP = new WeakMap();
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const _assert$1 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._assert;

class Auth {
  constructor(app, provider) {
    this.app = app;

    if (provider.isInitialized()) {
      this._delegate = provider.getImmediate();
      this.linkUnderlyingAuth();
      return;
    }

    const {
      apiKey
    } = app.options; // TODO: platform needs to be determined using heuristics

    _assert$1(apiKey, "invalid-api-key"
    /* exp.AuthErrorCode.INVALID_API_KEY */
    , {
      appName: app.name
    }); // TODO: platform needs to be determined using heuristics


    _assert$1(apiKey, "invalid-api-key"
    /* exp.AuthErrorCode.INVALID_API_KEY */
    , {
      appName: app.name
    }); // Only use a popup/redirect resolver in browser environments


    const resolver = typeof window !== 'undefined' ? CompatPopupRedirectResolver : undefined;
    this._delegate = provider.initialize({
      options: {
        persistence: buildPersistenceHierarchy(apiKey, app.name),
        popupRedirectResolver: resolver
      }
    });

    this._delegate._updateErrorMap(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.debugErrorMap);

    this.linkUnderlyingAuth();
  }

  get emulatorConfig() {
    return this._delegate.emulatorConfig;
  }

  get currentUser() {
    if (!this._delegate.currentUser) {
      return null;
    }

    return User.getOrCreate(this._delegate.currentUser);
  }

  get languageCode() {
    return this._delegate.languageCode;
  }

  set languageCode(languageCode) {
    this._delegate.languageCode = languageCode;
  }

  get settings() {
    return this._delegate.settings;
  }

  get tenantId() {
    return this._delegate.tenantId;
  }

  set tenantId(tid) {
    this._delegate.tenantId = tid;
  }

  useDeviceLanguage() {
    this._delegate.useDeviceLanguage();
  }

  signOut() {
    return this._delegate.signOut();
  }

  useEmulator(url, options) {
    _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.connectAuthEmulator(this._delegate, url, options);
  }

  applyActionCode(code) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.applyActionCode(this._delegate, code);
  }

  checkActionCode(code) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.checkActionCode(this._delegate, code);
  }

  confirmPasswordReset(code, newPassword) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.confirmPasswordReset(this._delegate, code, newPassword);
  }

  createUserWithEmailAndPassword(email, password) {
    var _this12 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return convertCredential(_this12._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.createUserWithEmailAndPassword(_this12._delegate, email, password));
    })();
  }

  fetchProvidersForEmail(email) {
    return this.fetchSignInMethodsForEmail(email);
  }

  fetchSignInMethodsForEmail(email) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.fetchSignInMethodsForEmail(this._delegate, email);
  }

  isSignInWithEmailLink(emailLink) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.isSignInWithEmailLink(this._delegate, emailLink);
  }

  getRedirectResult() {
    var _this13 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _assert$1(_isPopupRedirectSupported(), _this13._delegate, "operation-not-supported-in-this-environment"
      /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */
      );

      const credential = yield _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.getRedirectResult(_this13._delegate, CompatPopupRedirectResolver);

      if (!credential) {
        return {
          credential: null,
          user: null
        };
      }

      return convertCredential(_this13._delegate, Promise.resolve(credential));
    })();
  } // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
  // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it
  // out of autogenerated documentation pages to reduce accidental misuse.


  addFrameworkForLogging(framework) {
    _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.addFrameworkForLogging(this._delegate, framework);
  }

  onAuthStateChanged(nextOrObserver, errorFn, completed) {
    const {
      next,
      error,
      complete
    } = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onAuthStateChanged(next, error, complete);
  }

  onIdTokenChanged(nextOrObserver, errorFn, completed) {
    const {
      next,
      error,
      complete
    } = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onIdTokenChanged(next, error, complete);
  }

  sendSignInLinkToEmail(email, actionCodeSettings) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);
  }

  sendPasswordResetEmail(email, actionCodeSettings) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.sendPasswordResetEmail(this._delegate, email, actionCodeSettings || undefined);
  }

  setPersistence(persistence) {
    var _this14 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _validatePersistenceArgument(_this14._delegate, persistence);

      let converted;

      switch (persistence) {
        case Persistence.SESSION:
          converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserSessionPersistence;
          break;

        case Persistence.LOCAL:
          // Not using isIndexedDBAvailable() since it only checks if indexedDB is defined.
          const isIndexedDBFullySupported = yield _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.indexedDBLocalPersistence)._isAvailable();
          converted = isIndexedDBFullySupported ? _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.indexedDBLocalPersistence : _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserLocalPersistence;
          break;

        case Persistence.NONE:
          converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.inMemoryPersistence;
          break;

        default:
          return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._fail("argument-error"
          /* exp.AuthErrorCode.ARGUMENT_ERROR */
          , {
            appName: _this14._delegate.name
          });
      }

      return _this14._delegate.setPersistence(converted);
    })();
  }

  signInAndRetrieveDataWithCredential(credential) {
    return this.signInWithCredential(credential);
  }

  signInAnonymously() {
    return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInAnonymously(this._delegate));
  }

  signInWithCredential(credential) {
    return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInWithCredential(this._delegate, credential));
  }

  signInWithCustomToken(token) {
    return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInWithCustomToken(this._delegate, token));
  }

  signInWithEmailAndPassword(email, password) {
    return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInWithEmailAndPassword(this._delegate, email, password));
  }

  signInWithEmailLink(email, emailLink) {
    return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInWithEmailLink(this._delegate, email, emailLink));
  }

  signInWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }

  signInWithPopup(provider) {
    var _this15 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _assert$1(_isPopupRedirectSupported(), _this15._delegate, "operation-not-supported-in-this-environment"
      /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */
      );

      return convertCredential(_this15._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInWithPopup(_this15._delegate, provider, CompatPopupRedirectResolver));
    })();
  }

  signInWithRedirect(provider) {
    var _this16 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _assert$1(_isPopupRedirectSupported(), _this16._delegate, "operation-not-supported-in-this-environment"
      /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */
      );

      yield _savePersistenceForRedirect(_this16._delegate);
      return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.signInWithRedirect(_this16._delegate, provider, CompatPopupRedirectResolver);
    })();
  }

  updateCurrentUser(user) {
    // remove ts-ignore once overloads are defined for exp functions to accept compat objects
    // @ts-ignore
    return this._delegate.updateCurrentUser(user);
  }

  verifyPasswordResetCode(code) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.verifyPasswordResetCode(this._delegate, code);
  }

  unwrap() {
    return this._delegate;
  }

  _delete() {
    return this._delegate._delete();
  }

  linkUnderlyingAuth() {
    this._delegate.wrapped = () => this;
  }

}

Auth.Persistence = Persistence;

function wrapObservers(nextOrObserver, error, complete) {
  let next = nextOrObserver;

  if (typeof nextOrObserver !== 'function') {
    ({
      next,
      error,
      complete
    } = nextOrObserver);
  } // We know 'next' is now a function


  const oldNext = next;

  const newNext = user => oldNext(user && User.getOrCreate(user));

  return {
    next: newNext,
    error: error,
    complete
  };
}

function buildPersistenceHierarchy(apiKey, appName) {
  // Note this is slightly different behavior: in this case, the stored
  // persistence is checked *first* rather than last. This is because we want
  // to prefer stored persistence type in the hierarchy. This is an empty
  // array if window is not available or there is no pending redirect
  const persistences = _getPersistencesFromRedirect(apiKey, appName); // If "self" is available, add indexedDB


  if (typeof self !== 'undefined' && !persistences.includes(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.indexedDBLocalPersistence)) {
    persistences.push(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.indexedDBLocalPersistence);
  } // If "window" is available, add HTML Storage persistences


  if (typeof window !== 'undefined') {
    for (const persistence of [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserLocalPersistence, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.browserSessionPersistence]) {
      if (!persistences.includes(persistence)) {
        persistences.push(persistence);
      }
    }
  } // Add in-memory as a final fallback


  if (!persistences.includes(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.inMemoryPersistence)) {
    persistences.push(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.inMemoryPersistence);
  }

  return persistences;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class PhoneAuthProvider {
  constructor() {
    this.providerId = 'phone'; // TODO: remove ts-ignore when moving types from auth-types to auth-compat
    // @ts-ignore

    this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.PhoneAuthProvider(unwrap(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_1__["default"].auth()));
  }

  static credential(verificationId, verificationCode) {
    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.PhoneAuthProvider.credential(verificationId, verificationCode);
  }

  verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {
    return this._delegate.verifyPhoneNumber( // The implementation matches but the types are subtly incompatible
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    phoneInfoOptions, applicationVerifier);
  }

  unwrap() {
    return this._delegate;
  }

}

PhoneAuthProvider.PHONE_SIGN_IN_METHOD = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.PhoneAuthProvider.PHONE_SIGN_IN_METHOD;
PhoneAuthProvider.PROVIDER_ID = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.PhoneAuthProvider.PROVIDER_ID;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const _assert = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__._assert;

class RecaptchaVerifier {
  constructor(container, parameters, app = _firebase_app_compat__WEBPACK_IMPORTED_MODULE_1__["default"].app()) {
    var _a; // API key is required for web client RPC calls.


    _assert((_a = app.options) === null || _a === void 0 ? void 0 : _a.apiKey, "invalid-api-key"
    /* exp.AuthErrorCode.INVALID_API_KEY */
    , {
      appName: app.name
    });

    this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.RecaptchaVerifier(container, // eslint-disable-next-line @typescript-eslint/no-explicit-any
    parameters, // TODO: remove ts-ignore when moving types from auth-types to auth-compat
    // @ts-ignore
    app.auth());
    this.type = this._delegate.type;
  }

  clear() {
    this._delegate.clear();
  }

  render() {
    return this._delegate.render();
  }

  verify() {
    return this._delegate.verify();
  }

}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const AUTH_TYPE = 'auth-compat'; // Create auth components to register with firebase.
// Provides Auth public APIs.

function registerAuthCompat(instance) {
  instance.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component(AUTH_TYPE, container => {
    // getImmediate for FirebaseApp will always succeed
    const app = container.getProvider('app-compat').getImmediate();
    const authProvider = container.getProvider('auth');
    return new Auth(app, authProvider);
  }, "PUBLIC"
  /* ComponentType.PUBLIC */
  ).setServiceProps({
    ActionCodeInfo: {
      Operation: {
        EMAIL_SIGNIN: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ActionCodeOperation.EMAIL_SIGNIN,
        PASSWORD_RESET: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ActionCodeOperation.PASSWORD_RESET,
        RECOVER_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ActionCodeOperation.RECOVER_EMAIL,
        REVERT_SECOND_FACTOR_ADDITION: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,
        VERIFY_AND_CHANGE_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,
        VERIFY_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.ActionCodeOperation.VERIFY_EMAIL
      }
    },
    EmailAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.EmailAuthProvider,
    FacebookAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.FacebookAuthProvider,
    GithubAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.GithubAuthProvider,
    GoogleAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.GoogleAuthProvider,
    OAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.OAuthProvider,
    SAMLAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.SAMLAuthProvider,
    PhoneAuthProvider: PhoneAuthProvider,
    PhoneMultiFactorGenerator: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.PhoneMultiFactorGenerator,
    RecaptchaVerifier: RecaptchaVerifier,
    TwitterAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.TwitterAuthProvider,
    Auth,
    AuthCredential: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_2__.AuthCredential,
    Error: _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError
  }).setInstantiationMode("LAZY"
  /* InstantiationMode.LAZY */
  ).setMultipleInstances(false));
  instance.registerVersion(name, version);
}

registerAuthCompat(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ 46362:
/*!*****************************************************************************************!*\
  !*** ./node_modules/@angular/fire/node_modules/@firebase/auth/dist/esm2017/internal.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionCodeOperation": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   "ActionCodeURL": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ag),
/* harmony export */   "AuthCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.J),
/* harmony export */   "AuthErrorCodes": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.G),
/* harmony export */   "AuthImpl": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aJ),
/* harmony export */   "AuthPopup": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aM),
/* harmony export */   "EmailAuthCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.K),
/* harmony export */   "EmailAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.Q),
/* harmony export */   "FacebookAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.U),
/* harmony export */   "FactorId": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.F),
/* harmony export */   "FetchProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aN),
/* harmony export */   "GithubAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.W),
/* harmony export */   "GoogleAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.V),
/* harmony export */   "OAuthCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.L),
/* harmony export */   "OAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.X),
/* harmony export */   "OperationType": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.O),
/* harmony export */   "PhoneAuthCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.M),
/* harmony export */   "PhoneAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.P),
/* harmony export */   "PhoneMultiFactorGenerator": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.m),
/* harmony export */   "ProviderId": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.p),
/* harmony export */   "RecaptchaVerifier": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.R),
/* harmony export */   "SAMLAuthCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aO),
/* harmony export */   "SAMLAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.Y),
/* harmony export */   "SignInMethod": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.S),
/* harmony export */   "TotpMultiFactorGenerator": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.T),
/* harmony export */   "TotpSecret": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.n),
/* harmony export */   "TwitterAuthProvider": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.Z),
/* harmony export */   "UserImpl": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aI),
/* harmony export */   "_assert": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aA),
/* harmony export */   "_castAuth": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aH),
/* harmony export */   "_fail": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.av),
/* harmony export */   "_generateEventId": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aL),
/* harmony export */   "_getClientVersion": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aK),
/* harmony export */   "_getInstance": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aC),
/* harmony export */   "_getRedirectResult": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aE),
/* harmony export */   "_overrideRedirectResult": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aF),
/* harmony export */   "_persistenceKeyName": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aD),
/* harmony export */   "applyActionCode": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a5),
/* harmony export */   "beforeAuthStateChanged": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.w),
/* harmony export */   "browserLocalPersistence": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.b),
/* harmony export */   "browserPopupRedirectResolver": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.k),
/* harmony export */   "browserSessionPersistence": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a),
/* harmony export */   "checkActionCode": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a6),
/* harmony export */   "confirmPasswordReset": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a4),
/* harmony export */   "connectAuthEmulator": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.I),
/* harmony export */   "createUserWithEmailAndPassword": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a8),
/* harmony export */   "debugErrorMap": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.D),
/* harmony export */   "deleteUser": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.C),
/* harmony export */   "fetchSignInMethodsForEmail": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ad),
/* harmony export */   "getAdditionalUserInfo": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ao),
/* harmony export */   "getAuth": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.o),
/* harmony export */   "getIdToken": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.al),
/* harmony export */   "getIdTokenResult": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.am),
/* harmony export */   "getMultiFactorResolver": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aq),
/* harmony export */   "getRedirectResult": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.j),
/* harmony export */   "inMemoryPersistence": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.N),
/* harmony export */   "indexedDBLocalPersistence": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.i),
/* harmony export */   "initializeAuth": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.H),
/* harmony export */   "initializeRecaptchaConfig": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.t),
/* harmony export */   "isSignInWithEmailLink": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ab),
/* harmony export */   "linkWithCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a0),
/* harmony export */   "linkWithPhoneNumber": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.l),
/* harmony export */   "linkWithPopup": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.d),
/* harmony export */   "linkWithRedirect": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.g),
/* harmony export */   "multiFactor": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ar),
/* harmony export */   "onAuthStateChanged": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.x),
/* harmony export */   "onIdTokenChanged": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.v),
/* harmony export */   "parseActionCodeURL": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ah),
/* harmony export */   "prodErrorMap": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.E),
/* harmony export */   "reauthenticateWithCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a1),
/* harmony export */   "reauthenticateWithPhoneNumber": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.r),
/* harmony export */   "reauthenticateWithPopup": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.e),
/* harmony export */   "reauthenticateWithRedirect": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.h),
/* harmony export */   "reload": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ap),
/* harmony export */   "sendEmailVerification": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ae),
/* harmony export */   "sendPasswordResetEmail": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a3),
/* harmony export */   "sendSignInLinkToEmail": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aa),
/* harmony export */   "setPersistence": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.q),
/* harmony export */   "signInAnonymously": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__._),
/* harmony export */   "signInWithCredential": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.$),
/* harmony export */   "signInWithCustomToken": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a2),
/* harmony export */   "signInWithEmailAndPassword": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a9),
/* harmony export */   "signInWithEmailLink": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ac),
/* harmony export */   "signInWithPhoneNumber": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.s),
/* harmony export */   "signInWithPopup": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.c),
/* harmony export */   "signInWithRedirect": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.f),
/* harmony export */   "signOut": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.B),
/* harmony export */   "unlink": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.an),
/* harmony export */   "updateCurrentUser": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.z),
/* harmony export */   "updateEmail": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aj),
/* harmony export */   "updatePassword": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ak),
/* harmony export */   "updatePhoneNumber": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.u),
/* harmony export */   "updateProfile": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ai),
/* harmony export */   "useDeviceLanguage": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.y),
/* harmony export */   "verifyBeforeUpdateEmail": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.af),
/* harmony export */   "verifyPasswordResetCode": () => (/* reexport safe */ _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a7),
/* harmony export */   "addFrameworkForLogging": () => (/* binding */ addFrameworkForLogging),
/* harmony export */   "cordovaPopupRedirectResolver": () => (/* binding */ cordovaPopupRedirectResolver)
/* harmony export */ });
/* harmony import */ var C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ 57251);
/* harmony import */ var _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-e3d5d3f4.js */ 7270);
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ 47238);
/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/app */ 74941);
/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ 15993);
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @firebase/component */ 30504);








/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function _cordovaWindow() {
  return window;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * How long to wait after the app comes back into focus before concluding that
 * the user closed the sign in tab.
 */


const REDIRECT_TIMEOUT_MS = 2000;
/**
 * Generates the URL for the OAuth handler.
 */

function _generateHandlerUrl(_x, _x2, _x3) {
  return _generateHandlerUrl2.apply(this, arguments);
}
/**
 * Validates that this app is valid for this project configuration
 */


function _generateHandlerUrl2() {
  _generateHandlerUrl2 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (auth, event, provider) {
    var _a; // Get the cordova plugins


    const {
      BuildInfo
    } = _cordovaWindow();

    (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.as)(event.sessionId, 'AuthEvent did not contain a session ID');
    const sessionDigest = yield computeSha256(event.sessionId);
    const additionalParams = {};

    if ((0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.at)()) {
      // iOS app identifier
      additionalParams['ibi'] = BuildInfo.packageName;
    } else if ((0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.au)()) {
      // Android app identifier
      additionalParams['apn'] = BuildInfo.packageName;
    } else {
      (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.av)(auth, "operation-not-supported-in-this-environment"
      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
      );
    } // Add the display name if available


    if (BuildInfo.displayName) {
      additionalParams['appDisplayName'] = BuildInfo.displayName;
    } // Attached the hashed session ID


    additionalParams['sessionId'] = sessionDigest;
    return (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aw)(auth, provider, event.type, undefined, (_a = event.eventId) !== null && _a !== void 0 ? _a : undefined, additionalParams);
  });
  return _generateHandlerUrl2.apply(this, arguments);
}

function _validateOrigin(_x4) {
  return _validateOrigin2.apply(this, arguments);
}

function _validateOrigin2() {
  _validateOrigin2 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (auth) {
    const {
      BuildInfo
    } = _cordovaWindow();

    const request = {};

    if ((0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.at)()) {
      request.iosBundleId = BuildInfo.packageName;
    } else if ((0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.au)()) {
      request.androidPackageName = BuildInfo.packageName;
    } else {
      (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.av)(auth, "operation-not-supported-in-this-environment"
      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
      );
    } // Will fail automatically if package name is not authorized


    yield (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ax)(auth, request);
  });
  return _validateOrigin2.apply(this, arguments);
}

function _performRedirect(handlerUrl) {
  // Get the cordova plugins
  const {
    cordova
  } = _cordovaWindow();

  return new Promise(resolve => {
    cordova.plugins.browsertab.isAvailable(browserTabIsAvailable => {
      let iabRef = null;

      if (browserTabIsAvailable) {
        cordova.plugins.browsertab.openUrl(handlerUrl);
      } else {
        // TODO: Return the inappbrowser ref that's returned from the open call
        iabRef = cordova.InAppBrowser.open(handlerUrl, (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.ay)() ? '_blank' : '_system', 'location=yes');
      }

      resolve(iabRef);
    });
  });
}
/**
 * This function waits for app activity to be seen before resolving. It does
 * this by attaching listeners to various dom events. Once the app is determined
 * to be visible, this promise resolves. AFTER that resolution, the listeners
 * are detached and any browser tabs left open will be closed.
 */


function _waitForAppResume(_x5, _x6, _x7) {
  return _waitForAppResume2.apply(this, arguments);
}
/**
 * Checks the configuration of the Cordova environment. This has no side effect
 * if the configuration is correct; otherwise it throws an error with the
 * missing plugin.
 */


function _waitForAppResume2() {
  _waitForAppResume2 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (auth, eventListener, iabRef) {
    // Get the cordova plugins
    const {
      cordova
    } = _cordovaWindow();

    let cleanup = () => {};

    try {
      yield new Promise((resolve, reject) => {
        let onCloseTimer = null; // DEFINE ALL THE CALLBACKS =====

        function authEventSeen() {
          var _a; // Auth event was detected. Resolve this promise and close the extra
          // window if it's still open.


          resolve();
          const closeBrowserTab = (_a = cordova.plugins.browsertab) === null || _a === void 0 ? void 0 : _a.close;

          if (typeof closeBrowserTab === 'function') {
            closeBrowserTab();
          } // Close inappbrowser emebedded webview in iOS7 and 8 case if still
          // open.


          if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === 'function') {
            iabRef.close();
          }
        }

        function resumed() {
          if (onCloseTimer) {
            // This code already ran; do not rerun.
            return;
          }

          onCloseTimer = window.setTimeout(() => {
            // Wait two seeconds after resume then reject.
            reject((0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.az)(auth, "redirect-cancelled-by-user"
            /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */
            ));
          }, REDIRECT_TIMEOUT_MS);
        }

        function visibilityChanged() {
          if ((document === null || document === void 0 ? void 0 : document.visibilityState) === 'visible') {
            resumed();
          }
        } // ATTACH ALL THE LISTENERS =====
        // Listen for the auth event


        eventListener.addPassiveListener(authEventSeen); // Listen for resume and visibility events

        document.addEventListener('resume', resumed, false);

        if ((0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.au)()) {
          document.addEventListener('visibilitychange', visibilityChanged, false);
        } // SETUP THE CLEANUP FUNCTION =====


        cleanup = () => {
          eventListener.removePassiveListener(authEventSeen);
          document.removeEventListener('resume', resumed, false);
          document.removeEventListener('visibilitychange', visibilityChanged, false);

          if (onCloseTimer) {
            window.clearTimeout(onCloseTimer);
          }
        };
      });
    } finally {
      cleanup();
    }
  });
  return _waitForAppResume2.apply(this, arguments);
}

function _checkCordovaConfiguration(auth) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;

  const win = _cordovaWindow(); // Check all dependencies installed.
  // https://github.com/nordnet/cordova-universal-links-plugin
  // Note that cordova-universal-links-plugin has been abandoned.
  // A fork with latest fixes is available at:
  // https://www.npmjs.com/package/cordova-universal-links-plugin-fix


  (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aA)(typeof ((_a = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a === void 0 ? void 0 : _a.subscribe) === 'function', auth, "invalid-cordova-configuration"
  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */
  , {
    missingPlugin: 'cordova-universal-links-plugin-fix'
  }); // https://www.npmjs.com/package/cordova-plugin-buildinfo


  (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aA)(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== 'undefined', auth, "invalid-cordova-configuration"
  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */
  , {
    missingPlugin: 'cordova-plugin-buildInfo'
  }); // https://github.com/google/cordova-plugin-browsertab


  (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aA)(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === 'function', auth, "invalid-cordova-configuration"
  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */
  , {
    missingPlugin: 'cordova-plugin-browsertab'
  });

  (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aA)(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === 'function', auth, "invalid-cordova-configuration"
  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */
  , {
    missingPlugin: 'cordova-plugin-browsertab'
  }); // https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/


  (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aA)(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === 'function', auth, "invalid-cordova-configuration"
  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */
  , {
    missingPlugin: 'cordova-plugin-inappbrowser'
  });
}
/**
 * Computes the SHA-256 of a session ID. The SubtleCrypto interface is only
 * available in "secure" contexts, which covers Cordova (which is served on a file
 * protocol).
 */


function computeSha256(_x8) {
  return _computeSha.apply(this, arguments);
}

function _computeSha() {
  _computeSha = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (sessionId) {
    const bytes = stringToArrayBuffer(sessionId); // TODO: For IE11 crypto has a different name and this operation comes back
    //       as an object, not a promise. This is the old proposed standard that
    //       is used by IE11:
    // https://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/#cryptooperation-interface

    const buf = yield crypto.subtle.digest('SHA-256', bytes);
    const arr = Array.from(new Uint8Array(buf));
    return arr.map(num => num.toString(16).padStart(2, '0')).join('');
  });
  return _computeSha.apply(this, arguments);
}

function stringToArrayBuffer(str) {
  // This function is only meant to deal with an ASCII charset and makes
  // certain simplifying assumptions.
  (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.as)(/[0-9a-zA-Z]+/.test(str), 'Can only convert alpha-numeric strings');

  if (typeof TextEncoder !== 'undefined') {
    return new TextEncoder().encode(str);
  }

  const buff = new ArrayBuffer(str.length);
  const view = new Uint8Array(buff);

  for (let i = 0; i < str.length; i++) {
    view[i] = str.charCodeAt(i);
  }

  return view;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const SESSION_ID_LENGTH = 20;
/** Custom AuthEventManager that adds passive listeners to events */

class CordovaAuthEventManager extends _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aB {
  constructor() {
    super(...arguments);
    this.passiveListeners = new Set();
    this.initPromise = new Promise(resolve => {
      this.resolveInialized = resolve;
    });
  }

  addPassiveListener(cb) {
    this.passiveListeners.add(cb);
  }

  removePassiveListener(cb) {
    this.passiveListeners.delete(cb);
  } // In a Cordova environment, this manager can live through multiple redirect
  // operations


  resetRedirect() {
    this.queuedRedirectEvent = null;
    this.hasHandledPotentialRedirect = false;
  }
  /** Override the onEvent method */


  onEvent(event) {
    this.resolveInialized();
    this.passiveListeners.forEach(cb => cb(event));
    return super.onEvent(event);
  }

  initialized() {
    var _this = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      yield _this.initPromise;
    })();
  }

}
/**
 * Generates a (partial) {@link AuthEvent}.
 */


function _generateNewEvent(auth, type, eventId = null) {
  return {
    type,
    eventId,
    urlResponse: null,
    sessionId: generateSessionId(),
    postBody: null,
    tenantId: auth.tenantId,
    error: (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.az)(auth, "no-auth-event"
    /* AuthErrorCode.NO_AUTH_EVENT */
    )
  };
}

function _savePartialEvent(auth, event) {
  return storage()._set(persistenceKey(auth), event);
}

function _getAndRemoveEvent(_x9) {
  return _getAndRemoveEvent2.apply(this, arguments);
}

function _getAndRemoveEvent2() {
  _getAndRemoveEvent2 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (auth) {
    const event = yield storage()._get(persistenceKey(auth));

    if (event) {
      yield storage()._remove(persistenceKey(auth));
    }

    return event;
  });
  return _getAndRemoveEvent2.apply(this, arguments);
}

function _eventFromPartialAndUrl(partialEvent, url) {
  var _a, _b; // Parse the deep link within the dynamic link URL.


  const callbackUrl = _getDeepLinkFromCallback(url); // Confirm it is actually a callback URL.
  // Currently the universal link will be of this format:
  // https://<AUTH_DOMAIN>/__/auth/callback<OAUTH_RESPONSE>
  // This is a fake URL but is not intended to take the user anywhere
  // and just redirect to the app.


  if (callbackUrl.includes('/__/auth/callback')) {
    // Check if there is an error in the URL.
    // This mechanism is also used to pass errors back to the app:
    // https://<AUTH_DOMAIN>/__/auth/callback?firebaseError=<STRINGIFIED_ERROR>
    const params = searchParamsOrEmpty(callbackUrl); // Get the error object corresponding to the stringified error if found.

    const errorObject = params['firebaseError'] ? parseJsonOrNull(decodeURIComponent(params['firebaseError'])) : null;
    const code = (_b = (_a = errorObject === null || errorObject === void 0 ? void 0 : errorObject['code']) === null || _a === void 0 ? void 0 : _a.split('auth/')) === null || _b === void 0 ? void 0 : _b[1];
    const error = code ? (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.az)(code) : null;

    if (error) {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        error,
        urlResponse: null,
        sessionId: null,
        postBody: null
      };
    } else {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        sessionId: partialEvent.sessionId,
        urlResponse: callbackUrl,
        postBody: null
      };
    }
  }

  return null;
}

function generateSessionId() {
  const chars = [];
  const allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

  for (let i = 0; i < SESSION_ID_LENGTH; i++) {
    const idx = Math.floor(Math.random() * allowedChars.length);
    chars.push(allowedChars.charAt(idx));
  }

  return chars.join('');
}

function storage() {
  return (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aC)(_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.b);
}

function persistenceKey(auth) {
  return (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aD)("authEvent"
  /* KeyName.AUTH_EVENT */
  , auth.config.apiKey, auth.name);
}

function parseJsonOrNull(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
} // Exported for testing


function _getDeepLinkFromCallback(url) {
  const params = searchParamsOrEmpty(url);
  const link = params['link'] ? decodeURIComponent(params['link']) : undefined; // Double link case (automatic redirect)

  const doubleDeepLink = searchParamsOrEmpty(link)['link']; // iOS custom scheme links.

  const iOSDeepLink = params['deep_link_id'] ? decodeURIComponent(params['deep_link_id']) : undefined;
  const iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)['link'];
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
/**
 * Optimistically tries to get search params from a string, or else returns an
 * empty search params object.
 */


function searchParamsOrEmpty(url) {
  if (!(url === null || url === void 0 ? void 0 : url.includes('?'))) {
    return {};
  }

  const [_, ...rest] = url.split('?');
  return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.querystringDecode)(rest.join('?'));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * How long to wait for the initial auth event before concluding no
 * redirect pending
 */


const INITIAL_EVENT_TIMEOUT_MS = 500;

class CordovaPopupRedirectResolver {
  constructor() {
    this._redirectPersistence = _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.a;
    this._shouldInitProactively = true; // This is lightweight for Cordova

    this.eventManagers = new Map();
    this.originValidationPromises = {};
    this._completeRedirectFn = _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aE;
    this._overrideRedirectResult = _index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aF;
  }

  _initialize(auth) {
    var _this2 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const key = auth._key();

      let manager = _this2.eventManagers.get(key);

      if (!manager) {
        manager = new CordovaAuthEventManager(auth);

        _this2.eventManagers.set(key, manager);

        _this2.attachCallbackListeners(auth, manager);
      }

      return manager;
    })();
  }

  _openPopup(auth) {
    (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.av)(auth, "operation-not-supported-in-this-environment"
    /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
    );
  }

  _openRedirect(auth, provider, authType, eventId) {
    var _this3 = this;

    return (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _checkCordovaConfiguration(auth);

      const manager = yield _this3._initialize(auth);
      yield manager.initialized(); // Reset the persisted redirect states. This does not matter on Web where
      // the redirect always blows away application state entirely. On Cordova,
      // the app maintains control flow through the redirect.

      manager.resetRedirect();

      (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aG)();

      yield _this3._originValidation(auth);

      const event = _generateNewEvent(auth, authType, eventId);

      yield _savePartialEvent(auth, event);
      const url = yield _generateHandlerUrl(auth, event, provider);
      const iabRef = yield _performRedirect(url);
      return _waitForAppResume(auth, manager, iabRef);
    })();
  }

  _isIframeWebStorageSupported(_auth, _cb) {
    throw new Error('Method not implemented.');
  }

  _originValidation(auth) {
    const key = auth._key();

    if (!this.originValidationPromises[key]) {
      this.originValidationPromises[key] = _validateOrigin(auth);
    }

    return this.originValidationPromises[key];
  }

  attachCallbackListeners(auth, manager) {
    // Get the global plugins
    const {
      universalLinks,
      handleOpenURL,
      BuildInfo
    } = _cordovaWindow();

    const noEventTimeout = setTimeout( /*#__PURE__*/(0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      // We didn't see that initial event. Clear any pending object and
      // dispatch no event
      yield _getAndRemoveEvent(auth);
      manager.onEvent(generateNoEvent());
    }), INITIAL_EVENT_TIMEOUT_MS);

    const universalLinksCb = /*#__PURE__*/function () {
      var _ref2 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (eventData) {
        // We have an event so we can clear the no event timeout
        clearTimeout(noEventTimeout);
        const partialEvent = yield _getAndRemoveEvent(auth);
        let finalEvent = null;

        if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData['url'])) {
          finalEvent = _eventFromPartialAndUrl(partialEvent, eventData['url']);
        } // If finalEvent is never filled, trigger with no event


        manager.onEvent(finalEvent || generateNoEvent());
      });

      return function universalLinksCb(_x10) {
        return _ref2.apply(this, arguments);
      };
    }(); // Universal links subscriber doesn't exist for iOS, so we need to check


    if (typeof universalLinks !== 'undefined' && typeof universalLinks.subscribe === 'function') {
      universalLinks.subscribe(null, universalLinksCb);
    } // iOS 7 or 8 custom URL schemes.
    // This is also the current default behavior for iOS 9+.
    // For this to work, cordova-plugin-customurlscheme needs to be installed.
    // https://github.com/EddyVerbruggen/Custom-URL-scheme
    // Do not overwrite the existing developer's URL handler.


    const existingHandleOpenURL = handleOpenURL;
    const packagePrefix = `${BuildInfo.packageName.toLowerCase()}://`;

    _cordovaWindow().handleOpenURL = /*#__PURE__*/function () {
      var _ref3 = (0,C_Users_user_Desktop_futbuddy_repo_futbuddy_app_node_modules_angular_devkit_build_angular_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url) {
        if (url.toLowerCase().startsWith(packagePrefix)) {
          // We want this intentionally to float
          // eslint-disable-next-line @typescript-eslint/no-floating-promises
          universalLinksCb({
            url
          });
        } // Call the developer's handler if it is present.


        if (typeof existingHandleOpenURL === 'function') {
          try {
            existingHandleOpenURL(url);
          } catch (e) {
            // This is a developer error. Don't stop the flow of the SDK.
            console.error(e);
          }
        }
      });

      return function (_x11) {
        return _ref3.apply(this, arguments);
      };
    }();
  }

}
/**
 * An implementation of {@link PopupRedirectResolver} suitable for Cordova
 * based applications.
 *
 * @public
 */


const cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;

function generateNoEvent() {
  return {
    type: "unknown"
    /* AuthEventType.UNKNOWN */
    ,
    eventId: null,
    sessionId: null,
    urlResponse: null,
    postBody: null,
    tenantId: null,
    error: (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.az)("no-auth-event"
    /* AuthErrorCode.NO_AUTH_EVENT */
    )
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
// It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it out
// of autogenerated documentation pages to reduce accidental misuse.


function addFrameworkForLogging(auth, framework) {
  (0,_index_e3d5d3f4_js__WEBPACK_IMPORTED_MODULE_1__.aH)(auth)._logFramework(framework);
}



/***/ }),

/***/ 50735:
/*!**************************************************************************************************!*\
  !*** ./node_modules/@angular/fire/node_modules/@firebase/firestore-compat/dist/index.esm2017.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerFirestore": () => (/* binding */ registerFirestore)
/* harmony export */ });
/* harmony import */ var _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app-compat */ 80891);
/* harmony import */ var _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/firestore */ 62809);
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ 47238);
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ 30504);





const name = "@firebase/firestore-compat";
const version = "0.3.12";

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function validateSetOptions(methodName, options) {
    if (options === undefined) {
        return {
            merge: false
        };
    }
    if (options.mergeFields !== undefined && options.merge !== undefined) {
        throw new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.FirestoreError('invalid-argument', `Invalid options passed to function ${methodName}(): You cannot ` +
            'specify both "merge" and "mergeFields".');
    }
    return options;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Helper function to assert Uint8Array is available at runtime. */
function assertUint8ArrayAvailable() {
    if (typeof Uint8Array === 'undefined') {
        throw new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.FirestoreError('unimplemented', 'Uint8Arrays are not available in this environment.');
    }
}
/** Helper function to assert Base64 functions are available at runtime. */
function assertBase64Available() {
    if (!(0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._isBase64Available)()) {
        throw new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.FirestoreError('unimplemented', 'Blobs are unavailable in Firestore in this environment.');
    }
}
/** Immutable class holding a blob (binary data) */
class Blob {
    constructor(_delegate) {
        this._delegate = _delegate;
    }
    static fromBase64String(base64) {
        assertBase64Available();
        return new Blob(_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Bytes.fromBase64String(base64));
    }
    static fromUint8Array(array) {
        assertUint8ArrayAvailable();
        return new Blob(_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Bytes.fromUint8Array(array));
    }
    toBase64() {
        assertBase64Available();
        return this._delegate.toBase64();
    }
    toUint8Array() {
        assertUint8ArrayAvailable();
        return this._delegate.toUint8Array();
    }
    isEqual(other) {
        return this._delegate.isEqual(other._delegate);
    }
    toString() {
        return 'Blob(base64: ' + this.toBase64() + ')';
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isPartialObserver(obj) {
    return implementsAnyMethods(obj, ['next', 'error', 'complete']);
}
/**
 * Returns true if obj is an object and contains at least one of the specified
 * methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    const object = obj;
    for (const method of methods) {
        if (method in object && typeof object[method] === 'function') {
            return true;
        }
    }
    return false;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The persistence provider included with the full Firestore SDK.
 */
class IndexedDbPersistenceProvider {
    enableIndexedDbPersistence(firestore, forceOwnership) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.enableIndexedDbPersistence)(firestore._delegate, { forceOwnership });
    }
    enableMultiTabIndexedDbPersistence(firestore) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.enableMultiTabIndexedDbPersistence)(firestore._delegate);
    }
    clearIndexedDbPersistence(firestore) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.clearIndexedDbPersistence)(firestore._delegate);
    }
}
/**
 * Compat class for Firestore. Exposes Firestore Legacy API, but delegates
 * to the functional API of firestore-exp.
 */
class Firestore {
    constructor(databaseIdOrApp, _delegate, _persistenceProvider) {
        this._delegate = _delegate;
        this._persistenceProvider = _persistenceProvider;
        this.INTERNAL = {
            delete: () => this.terminate()
        };
        if (!(databaseIdOrApp instanceof _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._DatabaseId)) {
            this._appCompat = databaseIdOrApp;
        }
    }
    get _databaseId() {
        return this._delegate._databaseId;
    }
    settings(settingsLiteral) {
        const currentSettings = this._delegate._getSettings();
        if (!settingsLiteral.merge &&
            currentSettings.host !== settingsLiteral.host) {
            (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._logWarn)('You are overriding the original host. If you did not intend ' +
                'to override your settings, use {merge: true}.');
        }
        if (settingsLiteral.merge) {
            settingsLiteral = Object.assign(Object.assign({}, currentSettings), settingsLiteral);
            // Remove the property from the settings once the merge is completed
            delete settingsLiteral.merge;
        }
        this._delegate._setSettings(settingsLiteral);
    }
    useEmulator(host, port, options = {}) {
        (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.connectFirestoreEmulator)(this._delegate, host, port, options);
    }
    enableNetwork() {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.enableNetwork)(this._delegate);
    }
    disableNetwork() {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.disableNetwork)(this._delegate);
    }
    enablePersistence(settings) {
        let synchronizeTabs = false;
        let experimentalForceOwningTab = false;
        if (settings) {
            synchronizeTabs = !!settings.synchronizeTabs;
            experimentalForceOwningTab = !!settings.experimentalForceOwningTab;
            (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._validateIsNotUsedTogether)('synchronizeTabs', synchronizeTabs, 'experimentalForceOwningTab', experimentalForceOwningTab);
        }
        return synchronizeTabs
            ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this)
            : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
    }
    clearPersistence() {
        return this._persistenceProvider.clearIndexedDbPersistence(this);
    }
    terminate() {
        if (this._appCompat) {
            this._appCompat._removeServiceInstance('firestore-compat');
            this._appCompat._removeServiceInstance('firestore');
        }
        return this._delegate._delete();
    }
    waitForPendingWrites() {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.waitForPendingWrites)(this._delegate);
    }
    onSnapshotsInSync(arg) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshotsInSync)(this._delegate, arg);
    }
    get app() {
        if (!this._appCompat) {
            throw new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.FirestoreError('failed-precondition', "Firestore was not initialized using the Firebase SDK. 'app' is " +
                'not available');
        }
        return this._appCompat;
    }
    collection(pathString) {
        try {
            return new CollectionReference(this, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(this._delegate, pathString));
        }
        catch (e) {
            throw replaceFunctionName(e, 'collection()', 'Firestore.collection()');
        }
    }
    doc(pathString) {
        try {
            return new DocumentReference(this, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(this._delegate, pathString));
        }
        catch (e) {
            throw replaceFunctionName(e, 'doc()', 'Firestore.doc()');
        }
    }
    collectionGroup(collectionId) {
        try {
            return new Query(this, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collectionGroup)(this._delegate, collectionId));
        }
        catch (e) {
            throw replaceFunctionName(e, 'collectionGroup()', 'Firestore.collectionGroup()');
        }
    }
    runTransaction(updateFunction) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.runTransaction)(this._delegate, transaction => updateFunction(new Transaction(this, transaction)));
    }
    batch() {
        (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.ensureFirestoreConfigured)(this._delegate);
        return new WriteBatch(new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.WriteBatch(this._delegate, mutations => (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.executeWrite)(this._delegate, mutations)));
    }
    loadBundle(bundleData) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.loadBundle)(this._delegate, bundleData);
    }
    namedQuery(name) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.namedQuery)(this._delegate, name).then(expQuery => {
            if (!expQuery) {
                return null;
            }
            return new Query(this, 
            // We can pass `expQuery` here directly since named queries don't have a UserDataConverter.
            // Otherwise, we would have to create a new ExpQuery and pass the old UserDataConverter.
            expQuery);
        });
    }
}
class UserDataWriter extends _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.AbstractUserDataWriter {
    constructor(firestore) {
        super();
        this.firestore = firestore;
    }
    convertBytes(bytes) {
        return new Blob(new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Bytes(bytes));
    }
    convertReference(name) {
        const key = this.convertDocumentKey(name, this.firestore._databaseId);
        return DocumentReference.forKey(key, this.firestore, /* converter= */ null);
    }
}
function setLogLevel(level) {
    (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(level);
}
/**
 * A reference to a transaction.
 */
class Transaction {
    constructor(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(_firestore);
    }
    get(documentRef) {
        const ref = castReference(documentRef);
        return this._delegate
            .get(ref)
            .then(result => new DocumentSnapshot(this._firestore, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.DocumentSnapshot(this._firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, ref.converter)));
    }
    set(documentRef, data, options) {
        const ref = castReference(documentRef);
        if (options) {
            validateSetOptions('Transaction.set', options);
            this._delegate.set(ref, data, options);
        }
        else {
            this._delegate.set(ref, data);
        }
        return this;
    }
    update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
        const ref = castReference(documentRef);
        if (arguments.length === 2) {
            this._delegate.update(ref, dataOrField);
        }
        else {
            this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
        }
        return this;
    }
    delete(documentRef) {
        const ref = castReference(documentRef);
        this._delegate.delete(ref);
        return this;
    }
}
class WriteBatch {
    constructor(_delegate) {
        this._delegate = _delegate;
    }
    set(documentRef, data, options) {
        const ref = castReference(documentRef);
        if (options) {
            validateSetOptions('WriteBatch.set', options);
            this._delegate.set(ref, data, options);
        }
        else {
            this._delegate.set(ref, data);
        }
        return this;
    }
    update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
        const ref = castReference(documentRef);
        if (arguments.length === 2) {
            this._delegate.update(ref, dataOrField);
        }
        else {
            this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
        }
        return this;
    }
    delete(documentRef) {
        const ref = castReference(documentRef);
        this._delegate.delete(ref);
        return this;
    }
    commit() {
        return this._delegate.commit();
    }
}
/**
 * Wraps a `PublicFirestoreDataConverter` translating the types from the
 * experimental SDK into corresponding types from the Classic SDK before passing
 * them to the wrapped converter.
 */
class FirestoreDataConverter {
    constructor(_firestore, _userDataWriter, _delegate) {
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._delegate = _delegate;
    }
    fromFirestore(snapshot, options) {
        const expSnapshot = new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.QueryDocumentSnapshot(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, 
        /* converter= */ null);
        return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options !== null && options !== void 0 ? options : {});
    }
    toFirestore(modelObject, options) {
        if (!options) {
            return this._delegate.toFirestore(modelObject);
        }
        else {
            return this._delegate.toFirestore(modelObject, options);
        }
    }
    // Use the same instance of `FirestoreDataConverter` for the given instances
    // of `Firestore` and `PublicFirestoreDataConverter` so that isEqual() will
    // compare equal for two objects created with the same converter instance.
    static getInstance(firestore, converter) {
        const converterMapByFirestore = FirestoreDataConverter.INSTANCES;
        let untypedConverterByConverter = converterMapByFirestore.get(firestore);
        if (!untypedConverterByConverter) {
            untypedConverterByConverter = new WeakMap();
            converterMapByFirestore.set(firestore, untypedConverterByConverter);
        }
        let instance = untypedConverterByConverter.get(converter);
        if (!instance) {
            instance = new FirestoreDataConverter(firestore, new UserDataWriter(firestore), converter);
            untypedConverterByConverter.set(converter, instance);
        }
        return instance;
    }
}
FirestoreDataConverter.INSTANCES = new WeakMap();
/**
 * A reference to a particular document in a collection in the database.
 */
class DocumentReference {
    constructor(firestore, _delegate) {
        this.firestore = firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(firestore);
    }
    static forPath(path, firestore, converter) {
        if (path.length % 2 !== 0) {
            throw new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.FirestoreError('invalid-argument', 'Invalid document reference. Document ' +
                'references must have an even number of segments, but ' +
                `${path.canonicalString()} has ${path.length}`);
        }
        return new DocumentReference(firestore, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.DocumentReference(firestore._delegate, converter, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._DocumentKey(path)));
    }
    static forKey(key, firestore, converter) {
        return new DocumentReference(firestore, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.DocumentReference(firestore._delegate, converter, key));
    }
    get id() {
        return this._delegate.id;
    }
    get parent() {
        return new CollectionReference(this.firestore, this._delegate.parent);
    }
    get path() {
        return this._delegate.path;
    }
    collection(pathString) {
        try {
            return new CollectionReference(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(this._delegate, pathString));
        }
        catch (e) {
            throw replaceFunctionName(e, 'collection()', 'DocumentReference.collection()');
        }
    }
    isEqual(other) {
        other = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(other);
        if (!(other instanceof _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.DocumentReference)) {
            return false;
        }
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.refEqual)(this._delegate, other);
    }
    set(value, options) {
        options = validateSetOptions('DocumentReference.set', options);
        try {
            if (options) {
                return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(this._delegate, value, options);
            }
            else {
                return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(this._delegate, value);
            }
        }
        catch (e) {
            throw replaceFunctionName(e, 'setDoc()', 'DocumentReference.set()');
        }
    }
    update(fieldOrUpdateData, value, ...moreFieldsAndValues) {
        try {
            if (arguments.length === 1) {
                return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(this._delegate, fieldOrUpdateData);
            }
            else {
                return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(this._delegate, fieldOrUpdateData, value, ...moreFieldsAndValues);
            }
        }
        catch (e) {
            throw replaceFunctionName(e, 'updateDoc()', 'DocumentReference.update()');
        }
    }
    delete() {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(this._delegate);
    }
    onSnapshot(...args) {
        const options = extractSnapshotOptions(args);
        const observer = wrapObserver(args, result => new DocumentSnapshot(this.firestore, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.DocumentSnapshot(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(this._delegate, options, observer);
    }
    get(options) {
        let snap;
        if ((options === null || options === void 0 ? void 0 : options.source) === 'cache') {
            snap = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocFromCache)(this._delegate);
        }
        else if ((options === null || options === void 0 ? void 0 : options.source) === 'server') {
            snap = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocFromServer)(this._delegate);
        }
        else {
            snap = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(this._delegate);
        }
        return snap.then(result => new DocumentSnapshot(this.firestore, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.DocumentSnapshot(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
    }
    withConverter(converter) {
        return new DocumentReference(this.firestore, converter
            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))
            : this._delegate.withConverter(null));
    }
}
/**
 * Replaces the function name in an error thrown by the firestore-exp API
 * with the function names used in the classic API.
 */
function replaceFunctionName(e, original, updated) {
    e.message = e.message.replace(original, updated);
    return e;
}
/**
 * Iterates the list of arguments from an `onSnapshot` call and returns the
 * first argument that may be an `SnapshotListenOptions` object. Returns an
 * empty object if none is found.
 */
function extractSnapshotOptions(args) {
    for (const arg of args) {
        if (typeof arg === 'object' && !isPartialObserver(arg)) {
            return arg;
        }
    }
    return {};
}
/**
 * Creates an observer that can be passed to the firestore-exp SDK. The
 * observer converts all observed values into the format expected by the classic
 * SDK.
 *
 * @param args - The list of arguments from an `onSnapshot` call.
 * @param wrapper - The function that converts the firestore-exp type into the
 * type used by this shim.
 */
function wrapObserver(args, wrapper) {
    var _a, _b;
    let userObserver;
    if (isPartialObserver(args[0])) {
        userObserver = args[0];
    }
    else if (isPartialObserver(args[1])) {
        userObserver = args[1];
    }
    else if (typeof args[0] === 'function') {
        userObserver = {
            next: args[0],
            error: args[1],
            complete: args[2]
        };
    }
    else {
        userObserver = {
            next: args[1],
            error: args[2],
            complete: args[3]
        };
    }
    return {
        next: val => {
            if (userObserver.next) {
                userObserver.next(wrapper(val));
            }
        },
        error: (_a = userObserver.error) === null || _a === void 0 ? void 0 : _a.bind(userObserver),
        complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
    };
}
class DocumentSnapshot {
    constructor(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
    }
    get ref() {
        return new DocumentReference(this._firestore, this._delegate.ref);
    }
    get id() {
        return this._delegate.id;
    }
    get metadata() {
        return this._delegate.metadata;
    }
    get exists() {
        return this._delegate.exists();
    }
    data(options) {
        return this._delegate.data(options);
    }
    get(fieldPath, options
    // We are using `any` here to avoid an explicit cast by our users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        return this._delegate.get(fieldPath, options);
    }
    isEqual(other) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.snapshotEqual)(this._delegate, other._delegate);
    }
}
class QueryDocumentSnapshot extends DocumentSnapshot {
    data(options) {
        const data = this._delegate.data(options);
        (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._debugAssert)(data !== undefined, 'Document in a QueryDocumentSnapshot should exist');
        return data;
    }
}
class Query {
    constructor(firestore, _delegate) {
        this.firestore = firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(firestore);
    }
    where(fieldPath, opStr, value) {
        try {
            // The "as string" cast is a little bit of a hack. `where` accepts the
            // FieldPath Compat type as input, but is not typed as such in order to
            // not expose this via our public typings file.
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(fieldPath, opStr, value)));
        }
        catch (e) {
            throw replaceFunctionName(e, /(orderBy|where)\(\)/, 'Query.$1()');
        }
    }
    orderBy(fieldPath, directionStr) {
        try {
            // The "as string" cast is a little bit of a hack. `orderBy` accepts the
            // FieldPath Compat type as input, but is not typed as such in order to
            // not expose this via our public typings file.
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(fieldPath, directionStr)));
        }
        catch (e) {
            throw replaceFunctionName(e, /(orderBy|where)\(\)/, 'Query.$1()');
        }
    }
    limit(n) {
        try {
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limit)(n)));
        }
        catch (e) {
            throw replaceFunctionName(e, 'limit()', 'Query.limit()');
        }
    }
    limitToLast(n) {
        try {
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.limitToLast)(n)));
        }
        catch (e) {
            throw replaceFunctionName(e, 'limitToLast()', 'Query.limitToLast()');
        }
    }
    startAt(...args) {
        try {
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.startAt)(...args)));
        }
        catch (e) {
            throw replaceFunctionName(e, 'startAt()', 'Query.startAt()');
        }
    }
    startAfter(...args) {
        try {
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.startAfter)(...args)));
        }
        catch (e) {
            throw replaceFunctionName(e, 'startAfter()', 'Query.startAfter()');
        }
    }
    endBefore(...args) {
        try {
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.endBefore)(...args)));
        }
        catch (e) {
            throw replaceFunctionName(e, 'endBefore()', 'Query.endBefore()');
        }
    }
    endAt(...args) {
        try {
            return new Query(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(this._delegate, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.endAt)(...args)));
        }
        catch (e) {
            throw replaceFunctionName(e, 'endAt()', 'Query.endAt()');
        }
    }
    isEqual(other) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.queryEqual)(this._delegate, other._delegate);
    }
    get(options) {
        let query;
        if ((options === null || options === void 0 ? void 0 : options.source) === 'cache') {
            query = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocsFromCache)(this._delegate);
        }
        else if ((options === null || options === void 0 ? void 0 : options.source) === 'server') {
            query = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocsFromServer)(this._delegate);
        }
        else {
            query = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(this._delegate);
        }
        return query.then(result => new QuerySnapshot(this.firestore, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.QuerySnapshot(this.firestore._delegate, this._userDataWriter, this._delegate, result._snapshot)));
    }
    onSnapshot(...args) {
        const options = extractSnapshotOptions(args);
        const observer = wrapObserver(args, snap => new QuerySnapshot(this.firestore, new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.QuerySnapshot(this.firestore._delegate, this._userDataWriter, this._delegate, snap._snapshot)));
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(this._delegate, options, observer);
    }
    withConverter(converter) {
        return new Query(this.firestore, converter
            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))
            : this._delegate.withConverter(null));
    }
}
class DocumentChange {
    constructor(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
    }
    get type() {
        return this._delegate.type;
    }
    get doc() {
        return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);
    }
    get oldIndex() {
        return this._delegate.oldIndex;
    }
    get newIndex() {
        return this._delegate.newIndex;
    }
}
class QuerySnapshot {
    constructor(_firestore, _delegate) {
        this._firestore = _firestore;
        this._delegate = _delegate;
    }
    get query() {
        return new Query(this._firestore, this._delegate.query);
    }
    get metadata() {
        return this._delegate.metadata;
    }
    get size() {
        return this._delegate.size;
    }
    get empty() {
        return this._delegate.empty;
    }
    get docs() {
        return this._delegate.docs.map(doc => new QueryDocumentSnapshot(this._firestore, doc));
    }
    docChanges(options) {
        return this._delegate
            .docChanges(options)
            .map(docChange => new DocumentChange(this._firestore, docChange));
    }
    forEach(callback, thisArg) {
        this._delegate.forEach(snapshot => {
            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, snapshot));
        });
    }
    isEqual(other) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.snapshotEqual)(this._delegate, other._delegate);
    }
}
class CollectionReference extends Query {
    constructor(firestore, _delegate) {
        super(firestore, _delegate);
        this.firestore = firestore;
        this._delegate = _delegate;
    }
    get id() {
        return this._delegate.id;
    }
    get path() {
        return this._delegate.path;
    }
    get parent() {
        const docRef = this._delegate.parent;
        return docRef ? new DocumentReference(this.firestore, docRef) : null;
    }
    doc(documentPath) {
        try {
            if (documentPath === undefined) {
                // Call `doc` without `documentPath` if `documentPath` is `undefined`
                // as `doc` validates the number of arguments to prevent users from
                // accidentally passing `undefined`.
                return new DocumentReference(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(this._delegate));
            }
            else {
                return new DocumentReference(this.firestore, (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(this._delegate, documentPath));
            }
        }
        catch (e) {
            throw replaceFunctionName(e, 'doc()', 'CollectionReference.doc()');
        }
    }
    add(data) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)(this._delegate, data).then(docRef => new DocumentReference(this.firestore, docRef));
    }
    isEqual(other) {
        return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.refEqual)(this._delegate, other._delegate);
    }
    withConverter(converter) {
        return new CollectionReference(this.firestore, converter
            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))
            : this._delegate.withConverter(null));
    }
}
function castReference(documentRef) {
    return (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._cast)(documentRef, _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.DocumentReference);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
/**
 * A `FieldPath` refers to a field in a document. The path may consist of a
 * single field name (referring to a top-level field in the document), or a list
 * of field names (referring to a nested field in the document).
 */
class FieldPath {
    /**
     * Creates a FieldPath from the provided field names. If more than one field
     * name is provided, the path will point to a nested field in a document.
     *
     * @param fieldNames - A list of field names.
     */
    constructor(...fieldNames) {
        this._delegate = new _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.FieldPath(...fieldNames);
    }
    static documentId() {
        /**
         * Internal Note: The backend doesn't technically support querying by
         * document ID. Instead it queries by the entire document name (full path
         * included), but in the cases we currently support documentId(), the net
         * effect is the same.
         */
        return new FieldPath(_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__._FieldPath.keyField().canonicalString());
    }
    isEqual(other) {
        other = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(other);
        if (!(other instanceof _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.FieldPath)) {
            return false;
        }
        return this._delegate._internalPath.isEqual(other._internalPath);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FieldValue {
    constructor(_delegate) {
        this._delegate = _delegate;
    }
    static serverTimestamp() {
        const delegate = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)();
        delegate._methodName = 'FieldValue.serverTimestamp';
        return new FieldValue(delegate);
    }
    static delete() {
        const delegate = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteField)();
        delegate._methodName = 'FieldValue.delete';
        return new FieldValue(delegate);
    }
    static arrayUnion(...elements) {
        const delegate = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.arrayUnion)(...elements);
        delegate._methodName = 'FieldValue.arrayUnion';
        return new FieldValue(delegate);
    }
    static arrayRemove(...elements) {
        const delegate = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.arrayRemove)(...elements);
        delegate._methodName = 'FieldValue.arrayRemove';
        return new FieldValue(delegate);
    }
    static increment(n) {
        const delegate = (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.increment)(n);
        delegate._methodName = 'FieldValue.increment';
        return new FieldValue(delegate);
    }
    isEqual(other) {
        return this._delegate.isEqual(other._delegate);
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const firestoreNamespace = {
    Firestore,
    GeoPoint: _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.GeoPoint,
    Timestamp: _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp,
    Blob,
    Transaction,
    WriteBatch,
    DocumentReference,
    DocumentSnapshot,
    Query,
    QueryDocumentSnapshot,
    QuerySnapshot,
    CollectionReference,
    FieldPath,
    FieldValue,
    setLogLevel,
    CACHE_SIZE_UNLIMITED: _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.CACHE_SIZE_UNLIMITED
};
/**
 * Configures Firestore as part of the Firebase SDK by calling registerComponent.
 *
 * @param firebase - The FirebaseNamespace to register Firestore with
 * @param firestoreFactory - A factory function that returns a new Firestore
 *    instance.
 */
function configureForFirebase(firebase, firestoreFactory) {
    firebase.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component('firestore-compat', container => {
        const app = container.getProvider('app-compat').getImmediate();
        const firestoreExp = container.getProvider('firestore').getImmediate();
        return firestoreFactory(app, firestoreExp);
    }, 'PUBLIC').setServiceProps(Object.assign({}, firestoreNamespace)));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Registers the main Firestore build with the components framework.
 * Persistence can be enabled via `firebase.firestore().enablePersistence()`.
 */
function registerFirestore(instance) {
    configureForFirebase(instance, (app, firestoreExp) => new Firestore(app, firestoreExp, new IndexedDbPersistenceProvider()));
    instance.registerVersion(name, version);
}
registerFirestore(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__["default"]);




/***/ }),

/***/ 90062:
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "switchMapTo": () => (/* binding */ switchMapTo)
/* harmony export */ });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./switchMap */ 62257);

function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__.switchMap)(() => innerObservable, resultSelector) : (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__.switchMap)(() => innerObservable);
}


/***/ }),

/***/ 81066:
/*!********************************************************************************************!*\
  !*** ./node_modules/@angular/fire/node_modules/firebase/compat/auth/dist/esm/index.esm.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _firebase_auth_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/auth-compat */ 47925);



/***/ }),

/***/ 63846:
/*!*************************************************************************************************!*\
  !*** ./node_modules/@angular/fire/node_modules/firebase/compat/firestore/dist/esm/index.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _firebase_firestore_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/firestore-compat */ 50735);



/***/ })

}]);
//# sourceMappingURL=default-node_modules_angular_fire_fesm2015_angular-fire-compat-firestore_js.js.map